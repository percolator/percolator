/*******************************************************************************
 Copyright 2006-2012 Lukas Käll <lukas.kall@scilifelab.se>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 *******************************************************************************/

#include "Caller.h"
#include "Version.h"
#ifndef _WIN32
  #include "unistd.h"
#endif
#include <iomanip>
#include <set>
#include <sys/types.h>
#include <sys/stat.h>

#ifdef _OPENMP
#include <omp.h>
#endif

#include "Analytics.h"
#include "Reset.h"
using namespace std;

Caller::Caller() :
    pNorm_(NULL), pCheck_(NULL), protEstimator_(NULL), enzyme_(NULL),
    tabInput_(true), readStdIn_(false), inputFN_(""), inputFNs_(), 
    xmlSchemaValidation_(true), protEstimatorDecoyPrefix_("auto"),
    tabOutputFN_(""), xmlOutputFN_(""), pepXMLOutputFN_(""),weightOutputFN_(""),
    psmResultFN_(""), peptideResultFN_(""), proteinResultFN_(""),
    decoyPsmResultFN_(""), decoyPeptideResultFN_(""), decoyProteinResultFN_(""),
    analytics_(true), 
    xmlPrintDecoys_(false), xmlPrintExpMass_(true), reportUniquePeptides_(true),
    reportPepXML_(false),
    targetDecoyCompetition_(false), useMixMax_(false), inputSearchType_("auto"),
    selectionFdr_(0.01), initialSelectionFdr_(0.01), testFdr_(0.01),
    numIterations_(10), maxPSMs_(0u),
    nestedXvalBins_(1u), selectedCpos_(0.0), selectedCneg_(0.0),
    reportEachIteration_(false), quickValidation_(false), 
    trainBestPositive_(false), numThreads_(3u), use_reset_alg_(false), use_composition_match_(false),
    use_irls_pep_(false), use_interpolating_pep_(false), use_pava_pep_(false) {
}

Caller::~Caller() {
  if (pNorm_) {
    delete pNorm_;
  }
  pNorm_ = NULL;
  if (pCheck_) {
    delete pCheck_;
  }
  pCheck_ = NULL;
  if (protEstimator_) {
    delete protEstimator_;
  }
  protEstimator_ = NULL;
  if (enzyme_) {
    delete enzyme_;
  }
  enzyme_ = NULL;
}

string Caller::extendedGreeter() {
  ostringstream oss;
  char* host = getenv("HOSTNAME");
  oss << greeter();
  oss << "Issued command:" << endl << call_ << endl;
  oss << "Started " << timer.getStartTimeStr() << endl;
  oss.seekp(-1, ios_base::cur);
  if (host) oss << " on " << host << endl;
  oss << "Hyperparameters: selectionFdr=" << selectionFdr_
      << ", Cpos=" << selectedCpos_ << ", Cneg=" << selectedCneg_
      << ", maxNiter=" << numIterations_ << endl;
  return oss.str();
}

string Caller::greeter() {
  ostringstream oss;
  oss << "Percolator version " << VERSION << ", ";
  oss << "Build Date " << __DATE__ << " " << __TIME__ << endl;
  oss << "Copyright (c) 2006-9 University of Washington. All rights reserved.\n"
      << "Written by Lukas Käll (lukall@u.washington.edu) in the\n"
      << "Department of Genome Sciences at the University of Washington.\n";
  return oss.str();
}

bool Caller::parseOptions(int argc, char **argv) {
  ostringstream callStream;
  callStream << argv[0];
  for (int i = 1; i < argc; i++) {
    callStream << " " << argv[i];
  }
  callStream << endl;
  call_ = callStream.str();
  call_ = call_.substr(0,call_.length()-1); // trim ending carriage return
  ostringstream intro, endnote;
  intro << greeter() << "\nUsage:\n";
  intro << "   percolator [-X pout.xml] [other options] pin.tsv\n";
  intro << "pin.tsv is the tab delimited output file generated by e.g. sqt2pin;\n";
  intro << "  The tab delimited fields should be:\n";
  intro << "    id <tab> label <tab> scannr <tab> feature1 <tab> ... <tab>\n";
  intro << "    featureN <tab> peptide <tab> proteinId1 <tab> .. <tab> proteinIdM\n";
  intro << "  Labels are interpreted as 1 -- positive set and test set, -1 -- negative set.\n";
  intro << "pout.xml is where the output will be written (ensure to have read\n";
  intro << "and write access on the file)." << std::endl;
  // init
  CommandLineParser cmd(intro.str());
  // available lower case letters:
  // available upper case letters:
  cmd.defineOption("X",
      "xmloutput",
      "Path to xml-output (pout) file.",
      "filename");
  cmd.defineOption("Q",
      "pepxml-output",
      "Write a rudimentary pepXML file with psm-level statistics to the specified filename.",
      "filename");
  cmd.defineOption("",
      "stdinput-tab",
      "Read percolator tab-input format (pin-tab) from standard input",
      "",
      TRUE_IF_SET);
  cmd.defineOption("e",
      "stdinput-xml",
      "Read percolator xml-input format (pin-xml) from standard input",
      "",
      TRUE_IF_SET);
  cmd.defineOption("Z",
      "decoy-xml-output",
      "Include decoys (PSMs, peptides and/or proteins) in the xml-output. Only available if -X is set.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("p",
      "Cpos",
      "Cpos, penalty for mistakes made on positive examples. Set by cross validation if not specified.",
      "value");
  cmd.defineOption("n",
      "Cneg",
      "Cneg, penalty for mistakes made on negative examples. Set by cross validation if not specified or if -p is not specified.",
      "value");
  cmd.defineOption("t",
      "testFDR",
      "False discovery rate threshold for evaluating best cross validation result and reported end result. Default = 0.01.",
      "value");
  cmd.defineOption("F",
      "trainFDR",
      "False discovery rate threshold to define positive examples in training. Set to testFDR if 0. Default = 0.01.",
      "value");
  cmd.defineOption("i",
      "maxiter",
      "Maximal number of iterations. Default = 10.",
      "number");
  cmd.defineOption("N",
      "subset-max-train",
      "Only train an SVM on a subset of <x> PSMs, and use the resulting score vector to evaluate the other PSMs. Recommended when analyzing huge numbers (>1 million) of PSMs. When set to 0, all PSMs are used for training as normal. Default = 0.",
      "number");
  cmd.defineOption("x",
      "quick-validation",
      "Quicker execution by reduced internal cross-validation.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("J",
      "tab-out",
      "Output computed features to given file in pin-tab format.",
      "filename");
  cmd.defineOption("j",
      "tab-in",
      "[set by default] Input file given in pin-tab format. This is the default setting, flag only present for backwards compatibility.",
      "filename");
  cmd.defineOption("k",
      "xml-in",
      "Input file given in deprecated pin-xml format generated by e.g. sqt2pin with the -k option",
      "filename");
  cmd.defineOption("K",
      "protein-name-separator",
      "The separator used in tab delimited input and output for separating protein names. Default = tab-char.",
      "char");
  cmd.defineOption("w",
      "weights",
      "Output final weights to the given file",
      "filename");
  cmd.defineOption("W",
      "init-weights",
      "Read the unnormalized initial weights from the third line of the given file. This can be the output of the --weights option from a previous Percolator analysis. Note that the weights must be in the same order as the features in the PSM input file(s).",
      "filename");
  cmd.defineOption(Option::NO_SHORT_OPT,
      "static",
      "Use the provided initial weights as a static model. If used, the --init-weights option must be specified.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("V",
      "default-direction",
      "Use given feature name as initial search direction, can be negated to indicate that a lower value is better.",
      "[-]?featureName");
  cmd.defineOption("v",
      "verbose",
      "Set verbosity of output: 0=no processing info, 5=all. Default = 2",
      "level");
  cmd.defineOption("o",
      "no-terminate",
      "Do not stop execution when encountering questionable SVM inputs or results.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("u",
      "unitnorm",
      "Use unit normalization [0-1] instead of standard deviation normalization",
      "",
      TRUE_IF_SET);
  cmd.defineOption("R",
      "test-each-iteration",
      "Measure performance on test set each iteration",
      "",
      TRUE_IF_SET);
  cmd.defineOption("O",
      "override",
      "Override error check and do not fall back on default score vector in case of suspect score vector from SVM.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("S",
      "seed",
      "Set seed of the random number generator. Default = 1",
      "value");
  cmd.defineOption("r",
      "results-peptides",
      "Output tab delimited results of peptides to a file instead of stdout (will be ignored if used with -U option)",
      "filename");
  cmd.defineOption("B",
      "decoy-results-peptides",
      "Output tab delimited results for decoy peptides into a file (will be ignored if used with -U option)",
      "filename");
  cmd.defineOption("m",
      "results-psms",
      "Output tab delimited results of PSMs to a file instead of stdout",
      "filename");
  cmd.defineOption("M",
      "decoy-results-psms",
      "Output tab delimited results for decoy PSMs into a file",
      "filename");
  cmd.defineOption("U",
      "only-psms",
      "Report results only at the PSM level. This flag causes Percolator to skip the step that selects the top-scoring PSM per peptide; hence, peptide-level results are left out and only PSM-level results are reported.",
      "",
      FALSE_IF_SET);
  cmd.defineOption("y",
      "post-processing-mix-max",
      "Use the mix-max method to assign q-values and PEPs. Note that this option only has an effect if the input PSMs are from separate target and decoy searches. This is the default setting.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("Y",
      "post-processing-tdc",
      "Replace the mix-max method by target-decoy competition for assigning q-values and PEPs. If the input PSMs are from separate target and decoy searches, Percolator's SVM scores will be used to eliminate the lower scoring target or decoy PSM(s) of each scan+expMass combination. If the input PSMs are detected to be coming from a concatenated search, this option will be turned on automatically, as this is incompatible with the mix-max method. In case this detection fails, turn this option on explicitly.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("I",
      "search-input",
      "Specify the type of target-decoy search: \"auto\" (Percolator attempts to detect the search type automatically), \"concatenated\" (single search on concatenated target-decoy protein db) or \"separate\" (two searches, one against target and one against decoy protein db). Default = \"auto\".",
      "value");
  cmd.defineOption("s",
      "no-schema-validation",
      "Skip validation of input file against xml schema.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("f",
      "picked-protein",
      "Use the picked protein-level FDR to infer protein probabilities. Provide the fasta file as the argument to this flag, which will be used for protein grouping based on an in-silico digest. If no fasta file is available or protein grouping is not desired, set this flag to \"auto\" to skip protein grouping.",
      "value");
  cmd.defineOption("l",
      "results-proteins",
      "Output tab delimited results of proteins to a file instead of stdout (Only valid if option -f is active)",
      "filename");
  cmd.defineOption("L",
      "decoy-results-proteins",
      "Output tab delimited results for decoy proteins into a file (Only valid if option -f is active)",
      "filename");
  cmd.defineOption("P",
      "protein-decoy-pattern",
      "Define the prefix to identify decoy proteins in the database for the picked-protein algorithm. This will have no effect on the target/decoy labels specified in the input file. One of \"auto\" (Percolator guesses the prefix from the input file) or \"'<DECOY NAME>'\" (search for decoys using the '<DECOY NAME>' pattern). Default = \"auto\".",
      "value");
  cmd.defineOption("z",
      "protein-enzyme",
      "Type of enzyme used for in silico protein digestion for picked protein-level FDR estimation. One of \"no_enzyme\",\"elastase\",\"pepsin\",\"proteinasek\",\"thermolysin\",\"trypsinp\",\"chymotrypsin\",\"lys-n\",\"lys-c\",\"arg-c\",\"asp-n\",\"glu-c\",\"trypsin\". Default=\"trypsin\".",
      "",
      "trypsin");
  cmd.defineOption("c",
      "protein-report-fragments",
      "By default, if the peptides associated with protein A are a proper subset of the peptides associated with protein B, then protein A is eliminated and all the peptides are considered as evidence for protein B. Note that this filtering is done based on the complete set of peptides in the database, not based on the identified peptides in the search results. Alternatively, if this option is set and if all of the identified peptides associated with protein B are also associated with protein A, then Percolator will report a comma-separated list of protein IDs, where the full-length protein B is first in the list and the fragment protein A is listed second. Commas inside protein IDs will be replaced by semicolons. Not available for Fido.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("g",
      "protein-report-duplicates",
      "If this option is set and multiple database proteins contain exactly the same set of peptides, then the IDs of these duplicated proteins will be reported as a comma-separated list, instead of the default behavior of randomly discarding all but one of the proteins. Commas inside protein IDs will be replaced by semicolons. Not available for Fido.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("",
      "no-analytics",
      "Swich off analytics reporting",
      "", TRUE_IF_SET);
  /* EXPERIMENTAL FLAGS: no long term support, flag names might be subject to change and behavior */
  cmd.defineOption(Option::EXPERIMENTAL_FEATURE,
      "num-threads",
      "Number of total parallel threads for SVM training during cross validation. Default (one thread per CV fold) = 3.",
      "value");
  cmd.defineOption(Option::EXPERIMENTAL_FEATURE,
      "nested-xval-bins",
      "Number of nested cross validation bins within each cross validation bin. This should reduce overfitting of the hyperparameters. Default = 1.",
      "value");
  cmd.defineOption(Option::EXPERIMENTAL_FEATURE,
      "spectral-counting-fdr",
      "Activates spectral counting on protein level (--picked-protein has to be set) at the specified PSM q-value threshold. Adds two columns, \"spec_count_unique\" and \"spec_count_all\", to the protein tab separated output, containing the spectral count for the peptides unique to the protein and the spectral count including shared peptides respectively.",
      "value");
  cmd.defineOption(Option::EXPERIMENTAL_FEATURE,
      "train-best-positive",
      "Enforce that, for each spectrum, at most one PSM is included in the positive set during each training iteration. If the user only provides one PSM per spectrum, this filter will have no effect.",
      "",
      TRUE_IF_SET);
  cmd.defineOption(Option::EXPERIMENTAL_FEATURE,
      "train-fdr-initial",
      "Set the FDR threshold for the first iteration. This is useful in cases where the original features do not display a good separation between targets and decoys. In subsequent iterations, the normal --trainFDR will be used.",
      "value");
  cmd.defineOption(Option::EXPERIMENTAL_FEATURE,
      "parameter-file",
      "Read flags from a parameter file. If flags are specified on the command line as well, these will override the ones in the parameter file.",
      "filename");
  cmd.defineOption(Option::EXPERIMENTAL_FEATURE,
      "reset-algorithm",
      "Run an implementation of the Percolator-RESET Algorithm.",
      "", TRUE_IF_SET);
  cmd.defineOption("",
      "irls-pep",
      "Calculate PEPs using a cubic spline fitted using penalized log-likelihood fitting as described in PMID:18689838. This used to be the default method.",
      "", TRUE_IF_SET);
  cmd.defineOption(Option::EXPERIMENTAL_FEATURE,
      "ip-pep",
      "Use scores instead of rank as independent variable when calculating PEPs.",
      "", TRUE_IF_SET);
  cmd.defineOption(Option::EXPERIMENTAL_FEATURE,
        "pava-pep",
        "Calculate PEPs using PAVA isotonic regression.",
        "", TRUE_IF_SET);
  cmd.defineOption(Option::EXPERIMENTAL_FEATURE,
      "composition-match",
      "Run an implementation of the Percolator-RESET psmsAndPeptides with target-decoy matching based on composition.",
      "", TRUE_IF_SET);
  cmd.defineOption(
    "RT",
    "output-retention-time",
    "Adds retention time column to the output file",
    "",
    TRUE_IF_SET);

  // finally parse and handle return codes (display help etc...)
  cmd.parseArgs(argc, argv);

  if(cmd.isOptionSet("output-retention-time")){
    outputRT_ = true; 
  }

  if (cmd.isOptionSet("parameter-file")) {
    cmd.parseArgsParamFile(cmd.options["parameter-file"]);
  }

  if (cmd.isOptionSet("verbose")) {
    Globals::getInstance()->setVerbose(cmd.getInt("verbose", 0, 10));
  }

  if (cmd.isOptionSet("no-terminate")) {
    Globals::getInstance()->setNoTerminate(true);
  }

  // now query the parsing results
  if (cmd.isOptionSet("xmloutput")) {
    xmlOutputFN_ = cmd.options["xmloutput"];
    checkIsWritable(xmlOutputFN_);
  }
  // pepXML
  if (cmd.isOptionSet("pepxml-output")) {
    pepXMLOutputFN_ = cmd.options["pepxml-output"];
    checkIsWritable(pepXMLOutputFN_);
    reportPepXML_ = true;
  }

  // filenames for outputting results to file
  if (cmd.isOptionSet("results-psms")) {
    psmResultFN_ = cmd.options["results-psms"];
    checkIsWritable(psmResultFN_);
  }
  if (cmd.isOptionSet("decoy-results-psms")) {
    decoyPsmResultFN_ = cmd.options["decoy-results-psms"];
    checkIsWritable(decoyPsmResultFN_);
  }

  if (cmd.isOptionSet("only-psms")) {
    reportUniquePeptides_ = false;

    // the different "hacks" below are mainly to keep backwards compatibility with old Mascot versions
    if (cmd.isOptionSet("results-peptides")) {
      if (!cmd.isOptionSet("results-psms")) {
        if (VERB > 0) {
          cerr
          << "WARNING: The -r/--results-peptides option cannot be used in conjunction with -U/--only-psms: no peptide level statistics\n"
          << "are calculated, redirecting PSM level statistics to provided file instead." << endl;
        }
        psmResultFN_ = cmd.options["results-peptides"];
        checkIsWritable(psmResultFN_);
      } else {
        cerr
        << "WARNING: The -r/--results-peptides option cannot be used in conjunction with -U/--only-psms: no peptide level statistics\n"
        << "are calculated, ignoring -r/--results-peptides option." << endl;
      }
    }
    if (cmd.isOptionSet("decoy-results-peptides")) {
      if (!cmd.isOptionSet("decoy-results-psms")) {
        if (VERB > 0) {
          cerr
          << "WARNING: The -B/--decoy-results-peptides option cannot be used in conjunction with -U/--only-psms: no peptide level statistics\n"
          << "are calculated, redirecting decoy PSM level statistics to provided file instead." << endl;
        }
        decoyPsmResultFN_ = cmd.options["decoy-results-peptides"];
        checkIsWritable(decoyPsmResultFN_);
      } else {
        cerr
        << "WARNING: The -B/--decoy-results-peptides option cannot be used in conjunction with -U/--only-psms: no peptide level statistics\n"
        << "are calculated, ignoring -B/--decoy-results-peptides option." << endl;
      }
    }
  } else {
    if (cmd.isOptionSet("results-peptides")) {
      peptideResultFN_ = cmd.options["results-peptides"];
      checkIsWritable(peptideResultFN_);
    }
    if (cmd.isOptionSet("decoy-results-peptides")) {
      decoyPeptideResultFN_ = cmd.options["decoy-results-peptides"];
      checkIsWritable(decoyPeptideResultFN_);
    }
  }

  if (cmd.isOptionSet("protein-enzyme")) {
    enzyme_ = Enzyme::createEnzyme(cmd.options["protein-enzyme"]);
  } else {
    enzyme_ = Enzyme::createEnzyme(Enzyme::TRYPSIN);
  }
  if (cmd.isOptionSet("no-analytics")) {
    analytics_ = false;
  }
  if (cmd.isOptionSet("reset-algorithm")) {
    use_reset_alg_ = true;
  }
  if (cmd.isOptionSet("composition-match")) {
    use_composition_match_ = true;
  }
  if (cmd.isOptionSet("irls-pep")) {
    use_irls_pep_ = true;
  }
  if (cmd.isOptionSet("ip-pep")) {
    use_interpolating_pep_ = true;
  }
  if (cmd.isOptionSet("pava-pep")) {
    use_pava_pep_ = true;
  }

  if (cmd.isOptionSet("xml-in")) {
    tabInput_ = false;
    inputFN_ = cmd.options["xml-in"];
  }

  if (cmd.isOptionSet("stdinput-xml")) {
    readStdIn_ = true;
    tabInput_ = false;
  }

  if (cmd.isOptionSet("tab-in")) {
    tabInput_ = true;
    inputFN_ = cmd.options["tab-in"];
  }

  if (cmd.isOptionSet("stdinput-tab")) {
    readStdIn_ = true;
    tabInput_ = true;
  }

  if (cmd.isOptionSet("Cpos")) {
    selectedCpos_ = cmd.getDouble("Cpos", 0.0, 1e127);
  }
  if (cmd.isOptionSet("Cneg")) {
    selectedCneg_ = cmd.getDouble("Cneg", 0.0, 1e127);
    if (selectedCpos_ == 0) {
      std::cerr << "WARNING: the positive penalty(cpos) is 0, therefore both the "
               << "positive and negative penalties are going "
               << "to be cross-validated. The option --Cneg has to be used together "
               << "with the option --Cpos" << std::endl;
    }
  }
  if (cmd.isOptionSet("tab-out")) {
    tabOutputFN_ = cmd.options["tab-out"];
    checkIsWritable(tabOutputFN_);
  }

  if (cmd.isOptionSet("weights")) {
    weightOutputFN_ = cmd.options["weights"];
    checkIsWritable(weightOutputFN_);
  }
  if (cmd.isOptionSet("init-weights")) {
    SanityCheck::setInitWeightFN(cmd.options["init-weights"]);
  }
  if (cmd.isOptionSet("default-direction")) {
    SanityCheck::setInitDefaultDirName(cmd.options["default-direction"]);
  }
  if (cmd.isOptionSet("unitnorm")) {
    Normalizer::setType(Normalizer::UNI);
  }
  if (cmd.isOptionSet("override")) {
    SanityCheck::setOverrule(true);
  }
  if (cmd.isOptionSet("test-each-iteration")) {
    reportEachIteration_ = true;
  }
  if (cmd.isOptionSet("quick-validation")) {
    quickValidation_ = true;
  }
  if (cmd.isOptionSet("train-best-positive")) {
    trainBestPositive_ = true;
  }
  if (cmd.isOptionSet("trainFDR")) {
    selectionFdr_ = cmd.getDouble("trainFDR", 0.0, 1.0);
    initialSelectionFdr_ = selectionFdr_;
  }
  if (cmd.isOptionSet("train-fdr-initial")) {
    initialSelectionFdr_ = cmd.getDouble("train-fdr-initial", 0.0, 1.0);
  }
  if (cmd.isOptionSet("testFDR")) {
    testFdr_ = cmd.getDouble("testFDR", 0.0, 1.0);
  }
  if (cmd.isOptionSet("maxiter")) {
    numIterations_ = cmd.getUInt("maxiter", 0, 1000);
  }
  if (cmd.isOptionSet("num-threads")) {
    numThreads_ = cmd.getUInt("num-threads", 1, 128);
  }
  if (cmd.isOptionSet("subset-max-train")) {
    maxPSMs_ = cmd.getUInt("subset-max-train", 0, 100000000);
  }
  if (cmd.isOptionSet("seed")) {
    PseudoRandom::setSeed(static_cast<unsigned long int>(cmd.getInt("seed", 1, 20000)));
  }
  if (cmd.isOptionSet("protein-name-separator")){
    PSMDescription::setProteinNameSeparator(cmd.options["protein-name-separator"]);
  }
  
  if (cmd.isOptionSet("no-schema-validation")) {
    xmlSchemaValidation_ = false;
  }
  if (cmd.isOptionSet("decoy-xml-output")) {
    xmlPrintDecoys_ = true;
  }
  if (cmd.isOptionSet("post-processing-mix-max")) {
    if (cmd.isOptionSet("post-processing-tdc")) {
      std::cerr << "Error: the -Y/--post-processing-tdc and "
        << "-y/--post-processing-mix-max options were both set. "
        << "Use only one of these options at a time." << std::endl;
      return 0;
    }
    useMixMax_ = true;
  } else if (cmd.isOptionSet("post-processing-tdc")) {
    targetDecoyCompetition_ = true;
  }
  if (cmd.isOptionSet("search-input")) {
    inputSearchType_ = cmd.options["search-input"];
    if (inputSearchType_ == "concatenated") {
      if (useMixMax_) {
        std::cerr << "Error: concatenated search specified for -I/--search-input"
            << " is incompatible with the specified -y/--post-processing-mix-max "
            << "option." << std::endl;
        return 0;
      }
      targetDecoyCompetition_ = false;
      useMixMax_ = false;
    } else if (inputSearchType_ == "separate") {
      if (!targetDecoyCompetition_) {
        useMixMax_ = true;
      }
    } else if (inputSearchType_ != "auto") {
      std::cerr << "Error: the -I/--search-input option has to be one out of "
                << "\"concatenated\", \"separate\" or \"auto\"." << std::endl;
      return 0;
    }
  }

  // If a static model is used, no nested CV is needed for Cpos and Cneg.
  // Also, their values don't matter.
  if (cmd.isOptionSet("static")) {
    numIterations_ = 0;
    selectedCpos_ = 0.5;
    selectedCneg_ = 0.5;
    skipNormalizeScores_ = true;
    Normalizer::setType(Normalizer::NONORM);
    if (!cmd.isOptionSet("init-weights")) {
      std::cerr << "Error: the --static option requires the --init-weights "
        << "option to be specified." << std::endl;
      return 0;
    }
  } else {
    skipNormalizeScores_ = false;
  }

  if (cmd.isOptionSet("nested-xval-bins")) {
    nestedXvalBins_ = cmd.getUInt("nested-xval-bins", 1, 1000);
  }
  // if there are no arguments left...
  if (cmd.arguments.size() == 0) {
    if(!cmd.isOptionSet("tab-in") && !cmd.isOptionSet("xml-in") && !cmd.isOptionSet("stdinput-xml") && !cmd.isOptionSet("stdinput-tab")){ // unless the input comes from -j, -k or -e option
      cerr << "Error: too few arguments.";
      cerr << "\nInvoke with -h option for help\n";
      return 0; // ...error
    }
  }

  // if there is at least one argument left...
  if (cmd.arguments.size() >= 1) {
    tabInput_ = true;
    inputFNs_ = cmd.arguments; // then it's the pin input
    if (cmd.isOptionSet("xml-in") || cmd.isOptionSet("tab-in")){ // and if the tab input is also present
      cerr << "Error: use one of either pin-xml or tab-delimited input format.";
      cerr << "\nInvoke with -h option for help.\n";
      return 0; // ...error
    }
    if (cmd.isOptionSet("stdinput-xml") || cmd.isOptionSet("stdinput-tab")){ // if stdin pin file is present
      cerr << "Error: the pin file has already been given as stdinput argument.";
      cerr << "\nInvoke with -h option for help.\n";
      return 0; // ...error
    }
  }

  if (cmd.isOptionSet("protein-decoy-pattern")) protEstimatorDecoyPrefix_ = cmd.options["protein-decoy-pattern"];

  if (cmd.isOptionSet("fido-protein") || cmd.isOptionSet("picked-protein")) {

    ProteinProbEstimator::setCalcProteinLevelProb(true);

    // Confidence estimation options (general protein prob options)
    bool protEstimatorOutputEmpirQVal = false;
    bool protEstimatorTrivialGrouping = true; // cannot be set on cmd line
    double protEstimatorAbsenceRatio = 1.0;
    double protEstimatorPeptideQvalThreshold = -1.0;

    protEstimatorOutputEmpirQVal = cmd.isOptionSet("fido-empirical-protein-q");

    if (cmd.isOptionSet("spectral-counting-fdr")) {
      protEstimatorPeptideQvalThreshold = cmd.getDouble("spectral-counting-fdr", 0.0, 1.0);
    }

    // Output file options
    if (cmd.isOptionSet("results-proteins")) {
      proteinResultFN_ = cmd.options["results-proteins"];
      checkIsWritable(proteinResultFN_);
    }
    if (cmd.isOptionSet("decoy-results-proteins")) {
      decoyProteinResultFN_ = cmd.options["decoy-results-proteins"];
      checkIsWritable(decoyProteinResultFN_);
    }

    if (cmd.isOptionSet("picked-protein")) {
      std::string fastaDatabase = cmd.options["picked-protein"];

      // default options
      double pickedProteinPvalueCutoff = 1.0;
      bool pickedProteinReportFragmentProteins = false;
      bool pickedProteinReportDuplicateProteins = false;
      if (cmd.isOptionSet("protein-report-fragments")) pickedProteinReportFragmentProteins = true;
      if (cmd.isOptionSet("protein-report-duplicates")) pickedProteinReportDuplicateProteins = true;

      protEstimator_ = new PickedProteinInterface(fastaDatabase,
          pickedProteinPvalueCutoff, pickedProteinReportFragmentProteins,
          pickedProteinReportDuplicateProteins,
          protEstimatorTrivialGrouping, protEstimatorAbsenceRatio,
          protEstimatorOutputEmpirQVal, protEstimatorDecoyPrefix_,
          protEstimatorPeptideQvalThreshold);
    }

  }


  return true;
}

/** Calculates the PSM and/or peptide probabilities
 * @param isUniquePeptideRun boolean indicating if we want peptide or PSM probabilities
 */
void Caller::calculatePSMProb(Scores& allScores, bool isUniquePeptideRun){
  // write output (cerr or xml) if this is the unique peptide run and the
  // reportUniquePeptides_ option was switched on OR if this is not the unique
  // peptide run and the option was switched off
  bool writeOutput = (isUniquePeptideRun == reportUniquePeptides_);

  if (reportUniquePeptides_ && VERB > 0 && writeOutput) {
    cerr << "Tossing out \"redundant\" PSMs keeping only the best scoring PSM "
        "for each unique peptide." << endl;
  }

  if (isUniquePeptideRun) {
    if (ProteinProbEstimator::getCalcProteinLevelProb()) {
      allScores.weedOutRedundant(protEstimator_->getPeptideSpecCounts(),
                                 protEstimator_->getSpecCountQvalThreshold());
    } else {
      allScores.weedOutRedundant();
    }
  } else if (targetDecoyCompetition_) {
    allScores.weedOutRedundantTDC();
    if (VERB > 0) {
      std::cerr << "Selected best-scoring PSM per file+scan+expMass"
        << " (target-decoy competition): "
        << allScores.posSize() << " target PSMs and "
        << allScores.negSize() << " decoy PSMs." << std::endl;
    }
  }

  if (VERB > 0 && writeOutput) {
    if (useMixMax_) {
      std::cerr << "Selecting pi_0=" << allScores.getPi0() << std::endl;
    }
    std::cerr << "Calculating q values." << std::endl;
  }

  int foundPSMs = allScores.calcQ(testFdr_);

  if (VERB > 0 && writeOutput) {
    if (useMixMax_) {
      std::cerr << "New pi_0 estimate on final list yields ";
    } else {
      std::cerr << "Final list yields ";
    }
    std::cerr << foundPSMs << " target " << (reportUniquePeptides_ ? "peptides" : "PSMs")
              << " with q<" << testFdr_ << "." << endl;
    std::cerr << "Calculating posterior error probabilities (PEPs)." << std::endl;
  }
  allScores.calcPep(use_irls_pep_, use_interpolating_pep_, use_pava_pep_);
  writeResults(allScores, isUniquePeptideRun, writeOutput);
}

void Caller::writeResults(Scores &allScores, bool isUniquePeptideRun, bool writeOutput) {

  if (VERB > 1 && writeOutput) {
    timer.stop();
    std::cerr << "Processing took " << timer.getCPUTimeStr()
                << " cpu seconds or " << timer.getWallTimeStr() << " seconds wall clock time." << endl;
  }

  std::string targetFN, decoyFN;
  if (isUniquePeptideRun) {
    targetFN = peptideResultFN_;
    decoyFN = decoyPeptideResultFN_;
  } else {
    targetFN = psmResultFN_;
    decoyFN = decoyPsmResultFN_;
  }
  if (!targetFN.empty()) {
    ofstream targetStream(targetFN.c_str(), ios::out);
    allScores.print(NORMAL, targetStream);
  } else if (writeOutput) {
    allScores.print(NORMAL);
  }
  if (!decoyFN.empty()) {
    ofstream decoyStream(decoyFN.c_str(), ios::out);
    allScores.print(SHUFFLED, decoyStream);
  }
}

/**
 * Calculates the protein probabilites by calling Fido and directly writes
 * the results to XML
 */
void Caller::calculateProteinProbabilities(Scores& allScores) {
  Timer localTimer;

  if (VERB > 0) {
    cerr << "\nCalculating protein level probabilities.\n";
    cerr << protEstimator_->printCopyright();
  }

  protEstimator_->initialize(allScores, enzyme_, protEstimatorDecoyPrefix_);

  if (VERB > 1) {
    std::cerr << "Initialized protein inference engine." << std::endl;
  }

  if (protEstimator_->getSpecCountQvalThreshold() > 0.0) {
    protEstimator_->addSpectralCounts(allScores);
    if (VERB > 1) {
      std::cerr << "Added spectral counts." << std::endl;
    }
  }

  protEstimator_->run();

  if (VERB > 1) {
    std::cerr << "Computing protein probabilities." << std::endl;
  }

  protEstimator_->computeProbabilities();

  if (VERB > 1) {
    std::cerr << "Computing protein statistics." << std::endl;
  }

  protEstimator_->computeStatistics();

  localTimer.stop();
  if (VERB > 1) {
    std::cerr << "Estimating protein probabilities took : " << localTimer.getCPUTimeStr() << 
      " cpu seconds or " << localTimer.getWallTimeStr() << " seconds wall clock time." << endl;
  }

  protEstimator_->printOut(proteinResultFN_, decoyProteinResultFN_);
}

void Caller::checkIsWritable(const std::string& filePath) {
  std::ofstream ofs(filePath.c_str());
  if (!ofs.is_open()) {
    ostringstream temp;
    temp << "ERROR: Could not open the file " << filePath << " for writing. " <<
      "Check if the folder exists and if you have permission to write." << std::endl;
    throw MyException(temp.str());
  }
}

std::istream& Caller::getDataInStream(std::ifstream& fileStream){
  if (!readStdIn_) {
    if (!tabInput_) fileStream.exceptions(ifstream::badbit | ifstream::failbit);
    fileStream.open(inputFN_.c_str(), ios::in);
  } else if (maxPSMs_ > 0u) {
    maxPSMs_ = 0u;
    std::cerr << "Warning: cannot use subset-max-train (-N flag) when reading "
              << "from stdin, training on all data instead." << std::endl;
  }
  return readStdIn_ ? std::cin : fileStream;
}

bool Caller::loadAndNormalizeData(std::istream &dataStream, XMLInterface& xmlInterface, SetHandler& setHandler, Scores& allScores){
  bool success;
  if (!tabInput_) {
    if (VERB > 1) {
      std::cerr << "Reading pin-xml input from datafile " << inputFN_ << std::endl;
    }
    success = xmlInterface.readPin(dataStream, inputFN_, setHandler, pCheck_, protEstimator_, enzyme_);
  } else {
    if (VERB > 1) {
      std::cerr << "Reading tab-delimited input from datafile " << inputFN_ << std::endl;
    }
    
    success = setHandler.readTab(dataStream, pCheck_);
  }

  // Reading input files (pin or temporary file)
  if (!success) {
    std::cerr << "ERROR: Failed to read in file, check if the correct " <<
                 "file-format was used." << std::endl;
    if (NO_TERMINATE) {
      std::cerr << "No-terminate flag set: ignoring error and continuing "
          << "without PSMs." << std::endl;
    } else {
      return false;
    }
  }

  if (VERB > 2) {
    std::cerr << "FeatureNames::getNumFeatures(): "<< FeatureNames::getNumFeatures() << endl;
  }

  setHandler.normalizeFeatures(pNorm_);

  /*
  auto search-input detection cases:
  true search   detected search  mix-max  tdc  flag for mix-max       flag for tdc
  separate      separate         yes      yes  none (but -y allowed)  -Y
  separate      concatenated     yes      yes  -y (force)             -Y
  concatenated  concatenated     no       yes  NA                     none (but -Y allowed)
  concatenated  separate         no       yes  NA                     -Y (force)
  */
  if (inputSearchType_ == "auto") {
    if (pCheck_->concatenatedSearch()) {
      if (useMixMax_) {
        if (VERB > 0) {
          std::cerr << "Warning: concatenated search input detected, "
            << "but overridden by -y flag: using mix-max anyway." << std::endl;
        }
      } else {
        if (VERB > 0) {
          if (targetDecoyCompetition_) {
            std::cerr << "Concatenated search input detected and "
              << "--post-processing-tdc flag set. Applying target-decoy "
              << "competition on Percolator scores."
              << std::endl;
          } else {
            std::cerr << "Concatenated search input detected, skipping both "
              << "target-decoy competition and mix-max." << std::endl;
          }
        }
      }
    } else { // separate searches detected
      if (targetDecoyCompetition_) { // this also captures the case where input was in reality from concatenated search
        if (VERB > 0) {
          std::cerr << "Separate target and decoy search inputs detected, "
            << "using target-decoy competition on Percolator scores." << std::endl;
        }
      } else {
        useMixMax_ = true;
        if (VERB > 0) {
          std::cerr << "Separate target and decoy search inputs detected, "
            << "using mix-max method." << std::endl;
        }
      }
    }
  } else if (pCheck_->concatenatedSearch() && inputSearchType_ == "separate") {
    if (VERB > 0) {
      std::cerr << "Warning: concatenated search input detected, but "
        << "overridden by -I flag specifying separate searches." << std::endl;
    }
  } else if (!pCheck_->concatenatedSearch() && inputSearchType_ == "concatenated") {
    if (VERB > 0) {
      std::cerr << "Warning: separate searches input detected, but "
        << "overridden by -I flag specifying a concatenated search." << std::endl;
    }
  }
  assert(!(useMixMax_ && targetDecoyCompetition_));

  allScores.setUsePi0(useMixMax_);
  allScores.populateWithPSMs(setHandler);

  if (VERB > 0 && useMixMax_ &&
        abs(1.0 - allScores.getTargetDecoySizeRatio()) > 0.1) {
    std::cerr << "Warning: The mix-max procedure is not well behaved when "
      << "# targets (" << allScores.posSize() << ") != "
      << "# decoys (" << allScores.negSize() << "). "
      << "Consider using target-decoy competition (-Y flag)." << std::endl;
  }
  return success;
}


/**
 * Executes the flow of the percolator process:
 * 1. reads in the input file
 * 2. trains the SVM
 * 3. calculate PSM probabilities
 * 4. (optional) calculate peptide probabilities
 * 5. (optional) calculate protein probabilities
 */
int Caller::run() {
  timer.reset();

  if (VERB > 0) {
    std::cerr << extendedGreeter();
  }
// skip for now
//  if (analytics_)
//    postToPostHog("percolator_startup");
#ifdef _OPENMP
  omp_set_num_threads(static_cast<int>(
    std::min((unsigned int)omp_get_max_threads(), numThreads_)));
#endif

  /* Validate tab file and get decoy prefix */
  TabFileValidator tabFileValidator;
  if (!tabFileValidator.validateTabFiles(inputFNs_, protEstimatorDecoyPrefix_)) {
    return 0;
  }

  if (inputFNs_.size() == 1) {
    inputFN_ = inputFNs_.at(0);
  } else if (inputFNs_.size() > 1) {
    tabInput_ = true;
    ValidateTabFile validateTab;
    inputFN_ = validateTab.concatenateMultiplePINs(inputFNs_);
  }

  int success = 0;
  std::ifstream fileStream;
  XMLInterface xmlInterface(xmlOutputFN_, pepXMLOutputFN_, xmlSchemaValidation_, xmlPrintDecoys_, xmlPrintExpMass_);
  SetHandler setHandler(maxPSMs_);
  setHandler.setDecoyPrefix(protEstimatorDecoyPrefix_);
  Scores allScores(useMixMax_);
  allScores.setOutputRT(outputRT_);

  if(!loadAndNormalizeData(getDataInStream(fileStream), xmlInterface, setHandler, allScores))
    exit(EXIT_FAILURE);

  if (use_reset_alg_) {
    if (VERB > 0) {
      std::cerr << "Running the Percolator-RESET algorithm." << std::endl;
    }
    vector<double> w(DataSet::getNumFeatures()+1,0.0);
    SanityCheck sc;
    std::cerr << "Selecting best separating single variable." << std::endl;
    sc.getInitDirection(allScores, pNorm_, w, selectionFdr_, initialSelectionFdr_);
    Scores output(false);

    Reset resetAlg;
    resetAlg.reset(allScores, output, selectionFdr_, pCheck_, 0.5, 1, w, use_composition_match_);

    // allScores.normalizeScores(selectionFdr_); Probably not needed
    writeResults(output, false, true);
    return 1;
  }


  CrossValidation crossValidation(quickValidation_, reportEachIteration_,
                                  testFdr_, selectionFdr_, initialSelectionFdr_, selectedCpos_,
                                  selectedCneg_, numIterations_, useMixMax_,
                                  nestedXvalBins_, trainBestPositive_, numThreads_, skipNormalizeScores_);

  int firstNumberOfPositives = crossValidation.preIterationSetup(allScores, pCheck_, pNorm_, setHandler.getFeaturePool());

  if (VERB > 0) {
    cerr << "Found " << firstNumberOfPositives << " test set positives with q<"
        << testFdr_ << " in initial direction" << endl;
  }

  timer.stop();
  if (VERB > 1) cerr << "Reading in data and feature calculation took "
      << timer.getCPUTimeStr() << " cpu seconds or " << timer.getWallTimeStr() << " seconds wall clock time." << endl;
  timer.reset();

  if (tabOutputFN_.length() > 0) {
    setHandler.writeTab(tabOutputFN_, pCheck_);
  }

  // Do the SVM training
  crossValidation.train(pNorm_);

  // Calculate the final SVM scores and clean up structures
  crossValidation.postIterationProcessing(allScores, pCheck_);

  if (weightOutputFN_.size() > 0) {
    ofstream weightStream(weightOutputFN_.c_str(), ios::out);
    crossValidation.printAllWeights(weightStream, pNorm_);
    weightStream.close();
  }

  if (setHandler.getMaxPSMs() > 0u) {
    if (VERB > 0) {
      cerr << "Scoring full list of PSMs with trained SVMs." << endl;
    }
    std::vector<double> rawWeights;
    crossValidation.getAvgWeights(rawWeights, pNorm_);
    setHandler.reset();
    allScores.reset();

    fileStream.clear();
    fileStream.seekg(0, ios::beg);
    if (!tabInput_) {
      success = xmlInterface.readAndScorePin(fileStream, rawWeights, allScores, inputFN_, setHandler, pCheck_, protEstimator_, enzyme_);
    } else {
      success = setHandler.readAndScoreTab(fileStream, rawWeights, allScores, pCheck_);
    }

    // Reading input files (pin or temporary file)
    if (!success) {
      ostringstream temp;
      std::cerr << "ERROR: Failed to read in file, check if the correct " 
        << "file-format was used." << std::endl;
      if (NO_TERMINATE) {
        std::cerr << "No-terminate flag set: ignoring error and continuing "
            << "without PSMs." << std::endl;
      } else {
        return 0;
      }
    }

    if (VERB > 1) {
      cerr << "Evaluated set contained " << allScores.posSize() << " positives and " << allScores.negSize() << " negatives." << endl;
    }

    allScores.postMergeStep();
    allScores.calcQ(selectionFdr_);
    allScores.normalizeScores(selectionFdr_, rawWeights);
  }

  calcAndOutputResult(allScores, xmlInterface);
  return 1;
}


void Caller::calcAndOutputResult(Scores& allScores, XMLInterface& xmlInterface){
  // calculate psms level probabilities TDA or TDC
  bool isUniquePeptideRun = false;
  calculatePSMProb(allScores, isUniquePeptideRun);

  if (xmlInterface.getXmlOutputFN().size() > 0){
    xmlInterface.writeXML_PSMs(allScores);
  }
  if (xmlInterface.getxmlPepOutputFN().size() > 0){
    xmlInterface.writePepXML_PSMs(allScores, selectionFdr_, protEstimatorDecoyPrefix_);
  }
  // calculate unique peptides level probabilities WOTE
  if (reportUniquePeptides_ || ProteinProbEstimator::getCalcProteinLevelProb()){
    isUniquePeptideRun = true;
    calculatePSMProb(allScores, isUniquePeptideRun);

    if (xmlInterface.getXmlOutputFN().size() > 0){
      xmlInterface.writeXML_Peptides(allScores);
    }
  }

  // calculate protein level probabilities with Fido or Picked-protein
  if (ProteinProbEstimator::getCalcProteinLevelProb()) {
    calculateProteinProbabilities(allScores);

    if (xmlInterface.getXmlOutputFN().size() > 0) {
      xmlInterface.writeXML_Proteins(protEstimator_);
    }
  }
  if (reportPepXML_) {
    xmlInterface.writePepXML(allScores, protEstimator_, call_);
  }
  // write output to file
  xmlInterface.writeXML(allScores, protEstimator_, call_);
}

