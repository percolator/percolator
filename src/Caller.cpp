/*******************************************************************************
 Copyright 2006-2009 Lukas Käll <lukas.kall@cbr.su.se>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 *******************************************************************************/

#include "Caller.h"
#include "unistd.h"
#include <iomanip>
#include <boost/lexical_cast.hpp>
#include <sys/types.h>
#include <sys/stat.h>
#ifdef _WIN32
  #ifndef __stdcall
    #define __stdcall
  #endif
#endif
#ifdef _WIN32
  #include <fcntl.h>
#endif
#include <boost/filesystem.hpp>
#include "Logger.h"

using namespace std;
using namespace xercesc;

const unsigned int Caller::xval_fold = 3;
const double requiredIncreaseOver2Iterations = 0.01;

/** some constants to be used to compare xml strings **/

//databases
static const XMLCh databasesStr[] = {
      chLatin_d, chLatin_a, chLatin_t, chLatin_a, chLatin_b, chLatin_a,
      chLatin_s, chLatin_e, chLatin_s, chNull };
     
      
//calibration
static const XMLCh calibrationStr[] = { chLatin_c, chLatin_a,
      chLatin_l, chLatin_i, chLatin_b, chLatin_r, chLatin_a,
      chLatin_t, chLatin_i, chLatin_o, chLatin_n, chNull };

//proteins
static const XMLCh proteinsStr[] = { chLatin_p, chLatin_r,
      chLatin_o, chLatin_t, chLatin_e, chLatin_i, chLatin_n,
      chLatin_s, chNull };

//protein      
static const XMLCh proteinStr[] = { chLatin_p, chLatin_r,
      chLatin_o, chLatin_t, chLatin_e, chLatin_i, chLatin_n, chNull };
      
//fragSpectrumScan 
static const XMLCh fragSpectrumScanStr[] = { chLatin_f, chLatin_r,
      chLatin_a, chLatin_g, chLatin_S, chLatin_p, chLatin_e,
      chLatin_c, chLatin_t, chLatin_r, chLatin_u, chLatin_m,
      chLatin_S, chLatin_c, chLatin_a, chLatin_n, chNull };   
      
      
/** some constants to be used to compare xml strings **/
      
Caller::Caller() :
        pNorm(NULL), pCheck(NULL), svmInput(NULL), protEstimator(NULL),
        forwardTabInputFN(""), decoyWC(""), resultFN(""), tabFN(""),
        xmlInputFN(""), xmlOutputFN(""), weightFN(""),
        tabInput(false), readStdIn(false),
        docFeatures(false), quickValidation(false), reportPerformanceEachIteration(false),
        reportUniquePeptides(true), calculateProteinLevelProb(false),
        schemaValidation(true), hasProteins(false), target_decoy_competition(false),
        test_fdr(0.01), selectionfdr(0.01), selectedCpos(0), selectedCneg(0),
        threshTestRatio(0.3), trainRatio(0.6), niter(10) {
}

Caller::~Caller() {
  if (pNorm) {
    delete pNorm;
  }
  pNorm = NULL;
  if (pCheck) {
    delete pCheck;
  }
  pCheck = NULL;
  if (svmInput) {
    delete svmInput;
  }
  svmInput = NULL;
  if (protEstimator) {
    delete protEstimator;
  }
  protEstimator = NULL;
  if(readStdIn) {
    rmdir(xmlInputDir);
    delete xmlInputDir;
  }
  xmlInputDir = NULL;
}

string Caller::extendedGreeter() {
  ostringstream oss;
  char* host = getenv("HOSTNAME");
  oss << greeter();
  oss << "Issued command:" << endl << call << endl;
  oss << "Started " << ctime(&startTime) << endl;
  oss.seekp(-1, ios_base::cur);
  if(host) oss << " on " << host << endl;
  oss << "Hyperparameters fdr=" << selectionfdr;
  oss << ", Cpos=" << selectedCpos << ", Cneg=" << selectedCneg
      << ", maxNiter=" << niter << endl;
  return oss.str();
}

string Caller::greeter() {
  ostringstream oss;
  oss << "Percolator version " << VERSION << ", ";
  oss << "Build Date " << __DATE__ << " " << __TIME__ << endl;
  oss << "Copyright (c) 2006-9 University of Washington. All rights reserved.\n"
      << "Written by Lukas Käll (lukall@u.washington.edu) in the\n"
      << "Department of Genome Sciences at the University of Washington.\n";
  return oss.str();
}

bool Caller::parseOptions(int argc, char **argv) {
  ostringstream callStream;
  callStream << argv[0];
  for (int i = 1; i < argc; i++) {
    callStream << " " << argv[i];
  }
  callStream << endl;
  call = callStream.str();
  call = call.substr(0,call.length()-1); // trim ending carriage return
  ostringstream intro, endnote;
  intro << greeter() << endl << "Usage:" << endl;
  intro << "   percolator [-X pout.xml] [other options] pin.xml" << endl;
  intro << "Where pin.xml is the output file generated by sqt2pin; pout.xml is where" << endl;
  intro << "the output will be written (ensure to have read and write access on the file)." << endl;
  // init
  CommandLineParser cmd(intro.str());
  cmd.defineOption("X",
      "xmloutput",
      "path to file in xml-output format (pout)",
      "filename");
  cmd.defineOption("e",
      "stdinput",
      "read xml-input format (pin) from standard input",
      "",
      TRUE_IF_SET);
  cmd.defineOption("Z",
      "decoy-xml-output",
      "Include decoys (PSMs, peptides and/or proteins) in the xml-output. Only available if -X is used.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("p",
      "Cpos",
      "Cpos, penalty for mistakes made on positive examples. Set by cross validation if not specified.",
      "value");
  cmd.defineOption("n",
      "Cneg",
      "Cneg, penalty for mistakes made on negative examples. Set by cross validation if not specified or -p not specified.",
      "value");
  cmd.defineOption("F",
      "trainFDR",
      "False discovery rate threshold to define positive examples in training. Set by cross validation if 0. Default is 0.01.",
      "value");
  cmd.defineOption("t",
      "testFDR",
      "False discovery rate threshold for evaluating best cross validation result and the reported end result. Default is 0.01.",
      "value"); 
  cmd.defineOption("i",
      "maxiter",
      "Maximal number of iterations",
      "number");
  cmd.defineOption("x",
      "quick-validation",
      "Quicker execution by reduced internal cross-validation.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("f",
      "train-ratio",
      "Fraction of the negative data set to be used as train set when only providing one negative set, \
      remaining examples will be used as test set. Set to 0.6 by default.",
      "value");
  cmd.defineOption("J",
      "tab-out",
      "Output the computed features to the given file in tab-delimited format. A file with the features with the given file name will be created",
      "file name");
  cmd.defineOption("j",
      "tab-in",
      "Input files are given as a tab delimited file. In this case the only argument should be a file name \
      of the data file. The tab delimited fields should be id <tab> label <tab> feature1 \
      <tab> ... <tab> featureN <tab> peptide <tab> proteinId1 <tab> .. <tab> proteinIdM \
      Labels are interpreted as 1 -- positive set \
      and test set, -1 -- negative set.\
      When the --doc option the first and second feature (third and fourth column) should contain \
      the retention time and difference between observed and calculated mass",
      "filename");
  cmd.defineOption("w",
      "weights",
      "Output final weights to the given file",
      "filename");
  cmd.defineOption("W",
      "init-weights",
      "Read initial weights from the given file (one per line)",
      "filename");
  cmd.defineOption("V",
      "default-direction",
      "The most informative feature given as feature number, can be negated to indicate that a lower value is better.",
      "featureNum");
  cmd.defineOption("v",
      "verbose",
      "Set verbosity of output: 0=no processing info, 5=all, default is 2",
      "level");
  cmd.defineOption("u",
      "unitnorm",
      "Use unit normalization [0-1] instead of standard deviation normalization",
      "",
      TRUE_IF_SET);
  cmd.defineOption("R",
      "test-each-iteration",
      "Measure performance on test set each iteration",
      "",
      TRUE_IF_SET);
  cmd.defineOption("O",
      "override",
      "Override error check and do not fall back on default score vector in case of suspect score vector",
      "",
      TRUE_IF_SET);
  cmd.defineOption("S",
      "seed",
      "Setting seed of the random number generator. Default value is 1",
      "value");
  cmd.defineOption("K",
      "klammer",
      "Retention time features calculated as in Klammer et al.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("D",
      "doc",
      "Include description of correct features.",
      "",
      MAYBE,
      "15");
  cmd.defineOption("r",
      "results",
      "Output tab delimited results to a file instead of stdout",
      "filename");
  cmd.defineOption("B",
      "decoy-results",
      "Output tab delimited results for decoys into a file",
      "filename");
  cmd.defineOption("U",
      "unique-peptides",
      "Do not remove redundant peptides, keep all PSMS and exclude peptide level probabilities.",
      "",
      FALSE_IF_SET);
  cmd.defineOption("s",
      "no-schema-validation",
      "skip validation of input file against xml schema.",
      "",
      TRUE_IF_SET);
  cmd.defineOption("c",
      "clock",
      "check time performance",
      "",
      TRUE_IF_SET);
  cmd.defineOption("M",
      "exp-mass",
      "include the experimental mass in the output file",
      "",
      TRUE_IF_SET);
  cmd.defineOption("A",
      "protein",
      "output protein level probabilities",
      "",
      TRUE_IF_SET);
  cmd.defineOption("a",
      "alpha",
      "Probability with which a present protein emits an associated peptide (to be used jointly with the -A option) \
       Set by grid search if not specified.",
      "value");
  cmd.defineOption("b",
      "beta",
      "Probability of the creation of a peptide from noise (to be used jointly with the -A option). Set by grid search if not specified",
      "value");
  cmd.defineOption("G",
      "gamma",
      "Prior probability of that a protein is present in the sample ( to be used with the -A option). Set by grid search if not specified",
      "value");
  cmd.defineOption("g",
      "allow-protein-group",
      "treat ties as if it were one protein (Only valid if option -A is active).",
      "",
      TRUE_IF_SET);
  cmd.defineOption("I",
      "protein-level-pi0",
      "use pi_0 value when calculating empirical q-values (no effect if option Q is activated) (Only valid if option -A is active).",
      "", 
      TRUE_IF_SET);
  cmd.defineOption("q",
      "empirical-protein-q", 		   
      "output empirical q-values and p-values (from target-decoy analysis) (Only valid if option -A is active).",
      "",
      TRUE_IF_SET);
  cmd.defineOption("N",
      "group-proteins", 		   
      "activates the grouping of proteins with similar connectivity, \
       for example if proteins P1 and P2 have the same peptides matching both of them, P1 and P2 can be grouped as one protein \
       (Only valid if option -A is active).",
      "",
      TRUE_IF_SET);
  cmd.defineOption("E",
      "no-separate-proteins", 		   
      "Proteins graph will not be separated in sub-graphs (Only valid if option -A is active).",
      "",
      TRUE_IF_SET); 
  cmd.defineOption("C",
      "no-prune-proteins", 		   
      "it does not prune peptides with a very low score (~0.0) which means that if a peptide with a very low score is matching two proteins,\
       when we prune the peptide,it will be duplicated to generate two new protein groups (Only valid if option -A is active).",
      "",
      TRUE_IF_SET);
  cmd.defineOption("d",
      "depth",
      "Setting depth 0 or 1 or 2 or 3 from high depth to low depth(less computational time) \
       of the grid search for the estimation Alpha,Beta and Gamma parameters for fido(Only valid if option -A is active). Default value is 3",
      "value");
  cmd.defineOption("Q",
      "protein-fdr",
      "Estimate Protein False Discovery Rate using Mayu's method, the FDR estimated will be used in the estimation of the empirical q-values. \
       (Only valid if option -A is active)(The pin file must contain a list of proteins with their respectives lenghts, check -F option in converters)",
      "",
      TRUE_IF_SET);
  cmd.defineOption("P",
      "pattern",
      "Define the text pattern to identify the decoy proteins and/or PSMs, set this up if the label that idenfifies the decoys in the database \
       is not the default (by default : ramdom) (Only valid if option -A  is active).",
      "value");
  cmd.defineOption("T",
      "reduce-tree",
      "Reduce the tree of proteins in order to estimate alpha,beta and gamma faster.(Only valid if option -A is active).",
      "",
      TRUE_IF_SET);
  cmd.defineOption("Y",
      "target-decoy-competition",
      "Use target decoy competition mode on the PSMs.(recommended when using -A).",
      "",
      TRUE_IF_SET);
  cmd.defineOption("H",
      "mse-rocN-threshold",
      "Q-value threshold that will be used in the computation of the MSE and ROC AUC score in the grid search (recommended 0.05 for normal size datasets and 0.1 for big size datasets).(Only valid if option -A is active).",
      "",
      "value");
  cmd.defineOption("W",
      "no-truncation",
      "Proteins with a very low score (< 0.001) will not be truncated (assigned 0.0 probability).(Only valid if option -A is active).",
      "",
      FALSE_IF_SET);
  
  // finally parse and handle return codes (display help etc...)
  cmd.parseArgs(argc, argv);
  // now query the parsing results
  if (cmd.optionSet("X")) xmlOutputFN = cmd.options["X"];
  
  if (cmd.optionSet("B")) {
    decoyOut = cmd.options["B"];
  }
  
  if (cmd.optionSet("r")) {
    resultFN = cmd.options["r"];
  }
  
  if (cmd.optionSet("U")) {
    if (cmd.optionSet("A")){
      cerr
      << "The -U option cannot be used in conjunction with -A: peptide level statistics\n"
      << "are needed to calculate protein level ones.";
      exit(0);
    }
    reportUniquePeptides = false;
  }

  if (cmd.optionSet("A")) {
  
    calculateProteinLevelProb = true;
    double alpha = -1;
    double beta = -1;
    double gamma = -1;
    double mse_threshold = 0.05;
    bool gridSearch = true;
    unsigned depth = 3;
    std::string decoyWC = "random";
    bool tiesAsOneProtein = cmd.optionSet("g");
    bool usePi0 = cmd.optionSet("I");
    bool outputEmpirQVal = cmd.optionSet("q");
    bool grouProteins = cmd.optionSet("N"); 
    bool mayusfdr = cmd.optionSet("Q");
    bool noprune = cmd.optionSet("C");
    bool noseparate = cmd.optionSet("E");
    bool tabDelimitedOut = false;
    bool outputDecoys = cmd.optionSet("Z");
    bool reduceTree = cmd.optionSet("T");
    bool truncate = cmd.optionSet("W");
    
    if (!resultFN.empty() || !decoyOut.empty()) tabDelimitedOut = true;
    
    if(mayusfdr && usePi0)
    {
      std::cerr << "ERROR : Pi0(option I) and Protein FDR(option Q) cannot be used "
      "together to estimate Protein Probabilities." << std::endl;
      exit(-1);
    }
  
    if (cmd.optionSet("d"))  depth = (cmd.getInt("d", 0, 3));
    if (cmd.optionSet("a"))  alpha = cmd.getDouble("a", 0.00, 1.0);
    if (cmd.optionSet("b"))  beta = cmd.getDouble("b", 0.00, 1.0);
    if (cmd.optionSet("G"))  gamma = cmd.getDouble("G", 0.00, 1.0);
    if (cmd.optionSet("H")) mse_threshold = cmd.getDouble("H",0.001,1.0);
    
    if(alpha != -1 && beta != -1 && gamma != - 1) gridSearch = false;

    protEstimator = new ProteinProbEstimator(alpha,beta,gamma,tiesAsOneProtein,usePi0,outputEmpirQVal,
					       grouProteins,noseparate,noprune,gridSearch,depth,decoyWC,mayusfdr,
					       outputDecoys,tabDelimitedOut,resultFN,decoyOut,reduceTree,truncate,mse_threshold);
  }
  
  if (cmd.optionSet("e")) {

    readStdIn = true;
    string str = "";
    try
    {
      boost::filesystem::path ph = boost::filesystem::unique_path();
      boost::filesystem::path dir = boost::filesystem::temp_directory_path() / ph;
      boost::filesystem::path file("pin-tmp.xml");
      xmlInputFN = std::string((dir / file).string()); 
      str =  dir.string();
      xmlInputDir = new char[str.size() + 1];
      std::copy(str.begin(), str.end(), xmlInputDir);
      xmlInputDir[str.size()] = '\0';
      if(boost::filesystem::is_directory(dir))
      {
	boost::filesystem::remove_all(dir);
      }
	
      boost::filesystem::create_directory(dir);
    } 
    catch (boost::filesystem::filesystem_error &e)
    {
      std::cerr << e.what() << std::endl;
    }
  }
  
  if (cmd.optionSet("p")) {
    selectedCpos = cmd.getDouble("p", 0.0, 1e127);
  }
  if (cmd.optionSet("n")) {
    selectedCneg = cmd.getDouble("n", 0.0, 1e127);
    if(selectedCpos == 0)
    {
      std::cerr << "WARNING, the positive penalty(cpos) is 0, therefore both the positive and negative penalties are going "
		 "to be cros-validated. The option --Cneg has to be used together with the option --Cpos" << std::endl;
    }
  }
  if (cmd.optionSet("J")) {
    tabFN = cmd.options["J"];
  }
  if (cmd.optionSet("j")) {
    tabInput = true;
    forwardTabInputFN = cmd.options["j"];
  }
  if (cmd.optionSet("w")) {
    weightFN = cmd.options["w"];
  }
  if (cmd.optionSet("W")) {
    SanityCheck::setInitWeightFN(cmd.options["W"]);
  }
  if (cmd.optionSet("V")) {
    SanityCheck::setInitDefaultDir(cmd.getInt("V", -100, 100));
  }
  if (cmd.optionSet("f")) {
    double frac = cmd.getDouble("f", 0.0, 1.0);
    trainRatio = frac;
  }
  if (cmd.optionSet("u")) {
    Normalizer::setType(Normalizer::UNI);
  }
  if (cmd.optionSet("O")) {
    SanityCheck::setOverrule(true);
  }
  if (cmd.optionSet("R")) {
    reportPerformanceEachIteration = true;
  }
  if (cmd.optionSet("x")) {
    quickValidation=true;
  }
  if (cmd.optionSet("v")) {
    Globals::getInstance()->setVerbose(cmd.getInt("v", 0, 10));
  }
  if (cmd.optionSet("F")) {
    selectionfdr = cmd.getDouble("F", 0.0, 1.0);
  }
  if (cmd.optionSet("t")) {
    test_fdr = cmd.getDouble("t", 0.0, 1.0);
  }
  if (cmd.optionSet("S")) {
    Scores::setSeed(cmd.getInt("S", 1, 20000));
  }
  if (cmd.optionSet("K")) {
    DescriptionOfCorrect::setKlammer(true);
  }
  if (cmd.optionSet("D")) {
    docFeatures = true;
    DataSet::setCalcDoc(true);
    DescriptionOfCorrect::setDocType(cmd.getInt("D", 0, 15));
  }
  if (cmd.optionSet("Z")) {
    Scores::setOutXmlDecoys(true);
  }
  if (cmd.optionSet("s")) {
    schemaValidation = false;
  }
  if (cmd.optionSet("c")) {
    Globals* g = Globals::getInstance();
    g->timeCheckPoint = true;
    g->checkTimeClock = clock();
  }
  if (cmd.optionSet("M"))
  {
    showExpMass = true;
    Scores::setShowExpMass(showExpMass);
  }
  if (cmd.optionSet("Y")) {
    target_decoy_competition = true; 
  }
  // if there are no arguments left...
  if (cmd.arguments.size() == 0) {
    if(!cmd.optionSet("j") && !cmd.optionSet("e") ){ // unless the input comes from -j option or -e option
      cerr << "Error: too few arguments.";
      cerr << "\nInvoke with -h option for help\n";
      exit(-1); // ...error
    }
  }
  // if there is one argument left...
  if (cmd.arguments.size() == 1) {
    xmlInputFN = cmd.arguments[0]; // then it's the pin input
    if(cmd.optionSet("j")){ // and if the tab input is also present
      cerr << "Error: use one of either pin or tab-delimited input format.";
      cerr << "\nInvoke with -h option for help.\n";
      exit(-1); // ...error
    }
    if(cmd.optionSet("e")){ // if stdin pin file is present
      cerr << "Error: the pin file has already been given as stdinput argument.";
      cerr << "\nInvoke with -h option for help.\n";
      exit(-1); // ...error
    }
  }
  // if there is more then one argument left...
  if (cmd.arguments.size() > 1) {
    cerr << "Error: too many arguments.";
    cerr << "\nInvoke with -h option for help\n";
    exit(-1); // ...error
  }

  return true;
}

void Caller::printWeights(ostream & weightStream, vector<double>& w) {
  weightStream
  << "# first line contains normalized weights, second line the raw weights"
  << endl;
  weightStream << DataSet::getFeatureNames().getFeatureNames() << "\tm0"
      << endl;
  weightStream.precision(3);
  weightStream << w[0];
  for (unsigned int ix = 1; ix < FeatureNames::getNumFeatures() + 1; ix++) {
    weightStream << "\t" << fixed << setprecision(4) << w[ix];
  }
  weightStream << endl;
  vector<double> ww(FeatureNames::getNumFeatures() + 1);
  pNorm->unnormalizeweight(w, ww);
  weightStream << ww[0];
  for (unsigned int ix = 1; ix < FeatureNames::getNumFeatures() + 1; ix++) {
    weightStream << "\t" << fixed << setprecision(4) << ww[ix];
  }
  weightStream << endl;
}

void Caller::filelessSetup(const unsigned int numFeatures,
    const unsigned int numSpectra,
    char** featureNames, double pi0) {
  pCheck = new SanityCheck();
  assert(pCheck);
  normal.filelessSetup(numFeatures, numSpectra, 1);
  shuffled.filelessSetup(numFeatures, numSpectra, -1);
  for (unsigned int ix = 0; ix < numFeatures; ix++) {
    string fn = featureNames[ix];
    DataSet::getFeatureNames().insertFeature(fn);
  }
}

void Caller::readFiles() {
  
  if (xmlInputFN.size() != 0) 
  {
    unsigned int nrTargets;
    unsigned int nrDecoys;
    
    xercesc::XMLPlatformUtils::Initialize();
    
    DataSet * targetSet = new DataSet();
    assert(targetSet);
    targetSet->setLabel(1);
    DataSet * decoySet = new DataSet();
    assert(decoySet);
    decoySet->setLabel(-1);
    
    try {
      
      namespace xml = xsd::cxx::xml;
      std::ifstream xmlInStream;
      xmlInStream.exceptions(ifstream::badbit | ifstream::failbit);
      xmlInStream.open(xmlInputFN.c_str());
      if (!xmlInStream) {
        cerr << "Can not open file " << xmlInputFN << endl;
        exit(EXIT_FAILURE);
      }

      string schemaDefinition= PIN_SCHEMA_LOCATION+string("percolator_in.xsd");
      string schema_major = boost::lexical_cast<string>(PIN_VERSION_MAJOR);
      string schema_minor = boost::lexical_cast<string>(PIN_VERSION_MINOR);
      parser p;
      xml_schema::dom::auto_ptr<xercesc::DOMDocument> doc(p.start(
          xmlInStream, xmlInputFN.c_str(), Caller::schemaValidation,
          schemaDefinition, schema_major, schema_minor));

      doc = p.next();
      // read enzyme element
      // the enzyme element is a subelement but CodeSynthesis Xsd does not
      // generate a class for it. (I am trying to find a command line option
      // that overrides this decision). As for now special treatment is needed
      char* value = XMLString::transcode(
          doc->getDocumentElement()->getTextContent());
      if(VERB > 1) std::cerr << "enzyme=" << value << std::endl;
      Enzyme::setEnzyme(value);
      XMLString::release(&value);
      doc = p.next();

      //checking if database is present to jump it
      if(XMLString::equals(databasesStr, doc->getDocumentElement()->getTagName()))
      {
	//NOTE I dont really need this info, do I? good to have it though
	/*
	std::auto_ptr< ::percolatorInNs::databases > 
	databases( new ::percolatorInNs::databases(*doc->getDocumentElement()));
	*/
	doc = p.next();
	Caller::hasProteins = true;
      }
      
      // read process_info element
      percolatorInNs::process_info
      processInfo(*doc->getDocumentElement());
      otherCall = processInfo.command_line();
      doc = p.next();


      if (XMLString::equals(calibrationStr,doc->getDocumentElement()->getTagName())) 
      {
	//NOTE the calibration should define the initial direction
        //percolatorInNs::calibration calibration(*doc->getDocumentElement());
        doc = p.next();
      };

      percolatorInNs::featureDescriptions featureDescriptions(*doc->getDocumentElement());

      FeatureNames& feNames = DataSet::getFeatureNames();
      feNames.setFromXml(featureDescriptions, docFeatures);
      targetSet->initFeatureTables(feNames.getNumFeatures(), docFeatures);
      decoySet->initFeatureTables(feNames.getNumFeatures(), docFeatures);

      // import info from xml: read Fragment Spectrum Scans
      for (doc = p.next(); doc.get()!= 0 && 
	XMLString::equals(fragSpectrumScanStr, doc->getDocumentElement()->getTagName()); doc = p.next()) 
      {
        percolatorInNs::fragSpectrumScan fragSpectrumScan(*doc->getDocumentElement());
	BOOST_FOREACH(const percolatorInNs::peptideSpectrumMatch &psm, fragSpectrumScan.peptideSpectrumMatch())
	{
	  if(psm.isDecoy())
	  {
	    decoySet->readPsm(psm,fragSpectrumScan.scanNumber());
	  }
	  else
	  {
	    targetSet->readPsm(psm,fragSpectrumScan.scanNumber());
	  }
	}
      }

      // import info from xml: read database proteins
      // only read them if they are present and the option of using mayusfdr is activated
      unsigned readProteins = 0;
      for (doc = p.next(); doc.get()!= 0 
	&& Caller::hasProteins && Caller::calculateProteinLevelProb && Caller::protEstimator->getMayuFdr()
	&& XMLString::equals(proteinStr, doc->getDocumentElement()->getTagName()); doc = p.next()) 
      {
        std::auto_ptr< ::percolatorInNs::protein > protein( new ::percolatorInNs::protein(*doc->getDocumentElement()));
	 protEstimator->addProteinDb(*protein);
	 ++readProteins;
      }
      
      if(Caller::calculateProteinLevelProb && Caller::protEstimator->getMayuFdr() && readProteins <= 0)
      {
	std::cerr << "\nWARNING : options -Q and -A are activated but the number of proteins found in the input file is zero.\n\
		       Did you run converters with the flag -F ?\n" << std::endl;
	Caller::protEstimator->setMayusFDR(false);
      }
      
      pCheck = SanityCheck::initialize(otherCall);
      assert(pCheck);
      normal.push_back_dataset(targetSet);
      shuffled.push_back_dataset(decoySet);
      normal.setSet();
      shuffled.setSet();
      xmlInStream.close();
    }

    catch (const xml_schema::exception& e) {
      std::cerr << e << endl;
      exit(EXIT_FAILURE);
    } catch (const std::ios_base::failure&) {
      std::cerr << "unable to open or read failure" << std::endl;
      exit(EXIT_FAILURE);
    } catch (const xercesc::DOMException& e) {
      char * tmpStr = XMLString::transcode(e.getMessage());
      std::cerr << "catch  xercesc::DOMException=" << tmpStr << std::endl;
      XMLString::release(&tmpStr);
    }
  } else if (tabInput) {
    pCheck = new SanityCheck();
    //NOTE here percolator read the whole file twice, one time to get the decoy PSMs and another time to get the 
    // 	   target PSMs. This could be done in one iteration.
    normal.readTab(forwardTabInputFN, 1);
    shuffled.readTab(forwardTabInputFN, -1);
    std::cerr << "Features:\n" << DataSet::getFeatureNames().getFeatureNames() << std::endl;
  } 
}

/* Train one of the crossvalidation bins */

int Caller::xv_process_one_bin(unsigned int set, vector<vector<double> >& w, bool updateDOC, vector<double>& cpos_vec, 
                               vector<double>& cfrac_vec, double &best_cpos, double &best_cfrac, vector_double* pWeights,
options * pOptions) {
  int bestTP = 0;
  if (VERB > 2) {
    cerr << "cross calidation - fold " << set + 1 << " out of "
         << xval_fold << endl;
  }
  vector<double> ww = w[set];
  vector<double> bestW = w[set];
  xv_train[set].calcScores(ww, selectionfdr);
  if (docFeatures && updateDOC) {
    xv_train[set].recalculateDescriptionOfGood(selectionfdr);
  }
  xv_train[set].generateNegativeTrainingSet(*svmInput, 1.0);
  xv_train[set].generatePositiveTrainingSet(*svmInput, selectionfdr, 1.0);
  if (VERB > 2) {
    cerr << "Calling with " << svmInput->positives << " positives and "
         << svmInput->negatives << " negatives\n";
  }
  struct vector_double* Outputs = new vector_double;
  Outputs->vec = new double[svmInput->positives + svmInput->negatives];
  Outputs->d = svmInput->positives + svmInput->negatives;
  vector<double>::iterator cpos, cfrac;
  for (cpos = cpos_vec.begin(); cpos != cpos_vec.end(); cpos++) {
    for (cfrac = cfrac_vec.begin(); cfrac != cfrac_vec.end(); cfrac++) {
      if (VERB > 2) cerr << "-cross validation with cpos=" << *cpos
          << ", cfrac=" << *cfrac << endl;
      int tp = 0;
      for (int ix = 0; ix < pWeights->d; ix++) {
        pWeights->vec[ix] = 0;
      }
      for (int ix = 0; ix < Outputs->d; ix++) {
        Outputs->vec[ix] = 0;
      }
      svmInput->setCost(*cpos, (*cpos) * (*cfrac));
      L2_SVM_MFN(*svmInput, pOptions, pWeights, Outputs);
      for (int i = FeatureNames::getNumFeatures() + 1; i--;) {
        ww[i] = pWeights->vec[i];
      }
      tp = xv_train[set].calcScores(ww, test_fdr);
      if (VERB > 2) {
        cerr << "- cross validation estimates " << tp
             << " target PSMs over " << test_fdr * 100 << "% FDR level"
             << endl;
      }
      if (tp >= bestTP) {
        if (VERB > 2) {
          cerr << "Better than previous result, store this" << endl;
        }
        bestTP = tp;
        bestW = ww;
        best_cpos = *cpos;
        best_cfrac = *cfrac;
      }
    }
    if (VERB > 2) cerr << "cross validation estimates " << bestTP
        / (xval_fold - 1) << " target PSMs with q<" << test_fdr
        << " for hyperparameters Cpos=" << best_cpos << ", Cneg="
        << best_cfrac * best_cpos << endl;
  }
  w[set]=bestW;
  delete[] Outputs->vec;
  delete Outputs;
  return bestTP;
}

/**
 * cross validation step
 */
int Caller::xv_step(vector<vector<double> >& w, bool updateDOC) {
  // Setup
  struct options* pOptions = new options;
  pOptions->lambda = 1.0;
  pOptions->lambda_u = 1.0;
  pOptions->epsilon = EPSILON;
  pOptions->cgitermax = CGITERMAX;
  pOptions->mfnitermax = MFNITERMAX;
  struct vector_double* pWeights = new vector_double;
  pWeights->d = FeatureNames::getNumFeatures() + 1;
  pWeights->vec = new double[pWeights->d];
  int estTP = 0;
  double best_cpos = 1, best_cfrac = 1;
  if (!quickValidation) {
    for (unsigned int set = 0; set < xval_fold; ++set) {
      estTP += xv_process_one_bin(set,w,updateDOC, xv_cposs, xv_cfracs, best_cpos, best_cfrac, pWeights, pOptions);   
    }
  } else {
    // Use limited internal cross validation, i.e take the cpos and cfrac values of the first bin 
    // and use it for the subsequent bins 
    estTP += xv_process_one_bin(0,w,updateDOC, xv_cposs, xv_cfracs, best_cpos, best_cfrac, pWeights, pOptions);
    vector<double> cp(1),cf(1);
    cp[0]=best_cpos; cf[0]= best_cfrac;
    for (unsigned int set = 1; set < xval_fold; ++set) {
      estTP += xv_process_one_bin(set,w,updateDOC, cp, cf, best_cpos, best_cfrac, pWeights, pOptions);   
    }
  }
  delete[] pWeights->vec;
  delete pWeights;
  delete pOptions;
  return estTP / (xval_fold - 1);
}

void Caller::train(vector<vector<double> >& w) {
  // iterate
  int foundPositivesOldOld=0, foundPositivesOld=0, foundPositives=0; 
  for (unsigned int i = 0; i < niter; i++) {
    if (VERB > 1) {
      cerr << "Iteration " << i + 1 << " :\t";
    }
    foundPositives = xv_step(w, true);
    if (VERB > 1) {
      cerr << "After the iteration step, " << foundPositives
          << " target PSMs with q<" << selectionfdr
          << " were estimated by cross validation" << endl;
    }
    if (VERB > 2) {
      cerr << "Obtained weights" << endl;
      for (size_t set = 0; set < xval_fold; ++set) {
        printWeights(cerr, w[set]);
      }
    }
    if (foundPositives>0 && foundPositivesOldOld>0 && quickValidation) {
      if ((double)(foundPositives-foundPositivesOldOld)<=(foundPositivesOldOld*requiredIncreaseOver2Iterations)) {
        if (VERB > 1) {
          cerr << "Performance increase over the last two iterations indicate that the algorithm has converged" << endl;
          cerr << "(" << foundPositives << " vs " << foundPositivesOldOld << ")" << endl;
        }
        break;
      }
    }    
    foundPositivesOldOld=foundPositivesOld;    
    foundPositivesOld=foundPositives;
  }
  if (VERB == 2) {
    cerr
    << "Obtained weights (only showing weights of first cross validation set)"
    << endl;
    printWeights(cerr, w[0]);
  }
  foundPositives = 0;
  for (size_t set = 0; set < xval_fold; ++set) {
    if (docFeatures) {
      xv_test[set].getDOC().copyDOCparameters(xv_train[set].getDOC());
      xv_test[set].setDOCFeatures();
    }
    foundPositives += xv_test[set].calcScores(w[set], test_fdr);
  }
  if (VERB > 0) {
    cerr << "After all training done, " << foundPositives << " target PSMs with q<"
        << test_fdr << " were found when measuring on the test set"
        << endl;
  }
  
}

void Caller::fillFeatureSets() {
  fullset.fillFeatures(normal, shuffled, reportUniquePeptides);
  if (VERB > 1) {
    cerr << "Train/test set contains " << fullset.posSize()
        << " positives and " << fullset.negSize()
        << " negatives, size ratio=" << fullset.targetDecoySizeRatio
        << " and pi0=" << fullset.pi0 << endl;
  }
  
  //check for the minimum recommended number of positive and negative hits
  if(fullset.posSize() <= (unsigned)(FeatureNames::getNumFeatures() * 5))
  {
    std::cerr << "\nWARNING : the number of positive samples read is too small to perform a correct clasification.\n" << std::endl;
  }
  if(fullset.negSize() <= (unsigned)(FeatureNames::getNumFeatures() * 5))
  {
    std::cerr << "\nWARNING : the number of negative samples read is too small to perform a correct clasification.\n" << std::endl;
  }
  
  //Normalize features
  set<DataSet*> all;
  all.insert(normal.getSubsets().begin(), normal.getSubsets().end());
  all.insert(shuffled.getSubsets().begin(), shuffled.getSubsets().end());
  if (docFeatures) {
    for (set<DataSet*>::iterator myset = all.begin(); myset != all.end(); ++myset) {
      (*myset)->setRetentionTime(scan2rt);
    }
  }
  if (tabFN.length() > 0) {
    SetHandler::writeTab(tabFN, normal, shuffled);
  }
  vector<double*> featuresV, rtFeaturesV;
  double* features;
  PSMDescription* pPSM;
  size_t ix;
  set<DataSet*>::iterator it;
  for (it = all.begin(); it != all.end(); ++it) {
    int ixPos = -1;
    while ((pPSM = (*it)->getNext(ixPos)) != NULL) {
      features = pPSM->features;
      featuresV.push_back(features);
      if (features = pPSM->retentionFeatures) {
        rtFeaturesV.push_back(features);
      }
    }
  }
  pNorm = Normalizer::getNormalizer();

  pNorm->setSet(featuresV,
      rtFeaturesV,
      FeatureNames::getNumFeatures(),
      docFeatures ? RTModel::totalNumRTFeatures() : 0);
  pNorm->normalizeSet(featuresV, rtFeaturesV);
}

int Caller::preIterationSetup(vector<vector<double> >& w) {
  
  svmInput = new AlgIn(fullset.size(), FeatureNames::getNumFeatures() + 1); // One input set, to be reused multiple times
  assert( svmInput );

  if (selectedCpos >= 0 && selectedCneg >= 0) {
    xv_train.resize(xval_fold);
    xv_test.resize(xval_fold);
    if(xmlInputFN.size() > 0){
    	// take advantage of spectrum information in xml input
    	fullset.createXvalSetsBySpectrum(xv_train, xv_test, xval_fold);
    } else {
    	fullset.createXvalSets(xv_train, xv_test, xval_fold);
    }

    if (selectionfdr <= 0.0) {
      selectionfdr = test_fdr;
    }
    if (selectedCpos > 0) {
      xv_cposs.push_back(selectedCpos);
    } else {
      xv_cposs.push_back(10);
      xv_cposs.push_back(1);
      xv_cposs.push_back(0.1);
      if (VERB > 0) {
        cerr << "selecting cpos by cross validation" << endl;
      }
    }
    if (selectedCpos > 0 && selectedCneg > 0) {
      xv_cfracs.push_back(selectedCneg / selectedCpos);
    } else {
      xv_cfracs.push_back(1.0 * fullset.targetDecoySizeRatio);
      xv_cfracs.push_back(3.0 * fullset.targetDecoySizeRatio);
      xv_cfracs.push_back(10.0 * fullset.targetDecoySizeRatio);
      if (VERB > 0) {
        cerr << "selecting cneg by cross validation" << endl;
      }
    }
    return pCheck->getInitDirection(xv_test, xv_train, pNorm, w, test_fdr);
  } else {
    vector<Scores> myset(1, fullset);
    cerr << "B" << endl;
    return pCheck->getInitDirection(myset, myset, pNorm, w, test_fdr);
  }
}

void Caller::writeXML_PSMs() {
  ofstream os;
  xmlOutputFN_PSMs = xmlOutputFN;
  xmlOutputFN_PSMs.append("writeXML_PSMs");
  os.open(xmlOutputFN_PSMs.c_str(), ios::out);

  os << "  <psms>" << endl;
  for (vector<ScoreHolder>::iterator psm = fullset.begin();
      psm != fullset.end(); ++psm) {
      os << *psm;
  }
  os << "  </psms>" << endl << endl;
  os.close();
}

void Caller::writeXML_Peptides() {
  ofstream os;
  xmlOutputFN_Peptides = xmlOutputFN;
  xmlOutputFN_Peptides.append("writeXML_Peptides");
  os.open(xmlOutputFN_Peptides.c_str(), ios::out);
  // append PEPTIDEs
  os << "  <peptides>" << endl;
  for (vector<ScoreHolder>::iterator psm = fullset.begin(); psm
  != fullset.end(); ++psm) {
    os << (ScoreHolderPeptide)*psm;
  }
  os << "  </peptides>" << endl << endl;
  os.close();
}

void Caller::writeXML_Proteins() {
  xmlOutputFN_Proteins = xmlOutputFN;
  xmlOutputFN_Proteins.append("writeXML_Proteins");
  protEstimator->writeOutputToXML(xmlOutputFN_Proteins);
}

void Caller::writeXML(){
  ofstream os;
  const string space = PERCOLATOR_OUT_NAMESPACE;
  string schema_major = boost::lexical_cast<string>(POUT_VERSION_MAJOR);
  string schema_minor = boost::lexical_cast<string>(POUT_VERSION_MINOR);
  const string schema = space +
      " https://github.com/percolator/percolator/raw/pout-" + schema_major +
      "-" + schema_minor + "/src/xml/percolator_out.xsd";
  os.open(xmlOutputFN.data(), ios::out | ios::binary);
  os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" << endl;
  os << "<percolator_output "
      << endl << "xmlns=\""<< space << "\" "
      << endl << "xmlns:p=\""<< space << "\" "
      << endl << "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" "
      << endl << "xsi:schemaLocation=\""<< schema <<"\" "
      << endl << "p:majorVersion=\"" << VERSION_MAJOR << "\" p:minorVersion=\""
      << VERSION_MINOR << "\" p:percolator_version=\"Percolator version "
      << VERSION << "\">\n"<< endl;
  os << "  <process_info>" << endl;
  os << "    <command_line>" << call << "</command_line>" << endl;

  os << "    <other_command_line>" << otherCall << "</other_command_line>\n";
  os << "    <pi_0_psms>" << pi_0_psms << "</pi_0_psms>" << endl;
  if(reportUniquePeptides)
    os << "    <pi_0_peptides>" << pi_0_peptides << "</pi_0_peptides>" << endl;
  if(calculateProteinLevelProb)
  {  
    if(protEstimator->getUsePio())
      os << "    <pi_0_proteins>" << protEstimator->getPi0() << "</pi_0_proteins>" << endl;
    if(protEstimator->getMayuFdr())
      os << "    <fdr_proteins>" << protEstimator->getFDR() << "</fdr_proteins>" << endl;
    os << "    <alpha>" << protEstimator->getAlpha() <<"</alpha>" << endl;
    os << "    <beta>"  << protEstimator->getBeta() <<"</beta>" << endl;
    os << "    <gamma>" << protEstimator->getGamma() <<"</gamma>" << endl;
  }
  os << "    <psms_qlevel>" <<  numberQpsms <<"</psms_qlevel>" << endl;
  if(reportUniquePeptides)
    os << "    <peptides_qlevel>" << fullset.getQvaluesBelowLevel(0.01) << "</peptides_qlevel>" << endl;
  if(calculateProteinLevelProb)
    os << "    <proteins_qlevel>" << protEstimator->getQvaluesBelowLevel(0.01) << "</proteins_qlevel>" << endl;  
  if (docFeatures) {
    os << "    <average_delta_mass>" << fullset.getDOC().getAvgDeltaMass()
                   << "</average_delta_mass>" << endl;
    os << "    <average_pi>" << fullset.getDOC().getAvgPI()
                   << "</average_pi>" << endl;
  }
  os << "  </process_info>" << endl << endl;

  // apppend PSMs
  ifstream ifs_psms(xmlOutputFN_PSMs.data(), ios::in | ios::binary);
  os << ifs_psms.rdbuf();
  ifs_psms.close();
  remove(xmlOutputFN_PSMs.c_str());
  // append Peptides
  if(reportUniquePeptides){
    ifstream ifs_peptides(xmlOutputFN_Peptides.data(), ios::in | ios::binary);
    os << ifs_peptides.rdbuf();
    ifs_peptides.close();
    remove(xmlOutputFN_Peptides.c_str());
  }
  // append Proteins
  if(calculateProteinLevelProb){
    ifstream ifs_proteins(xmlOutputFN_Proteins.data(), ios::in | ios::binary);
    os << ifs_proteins.rdbuf();
    ifs_proteins.close();
    remove(xmlOutputFN_Proteins.c_str());
  }

  os << "</percolator_output>" << endl;
  os.close();
}

void Caller::calculatePSMProb(bool isUniquePeptideRun,Scores *fullset, time_t& procStart,
    clock_t& procStartClock, vector<vector<double> >& w, double& diff, bool TDC){
  // write output (cerr or xml) if this is the unique peptide run and the
  // reportUniquePeptides option was switched on OR if this is not the unique
  // peptide run and the option was switched off
  
  bool writeOutput = (isUniquePeptideRun == reportUniquePeptides);
  
  if (reportUniquePeptides && VERB > 0 && writeOutput) {
    cerr << "Tossing out \"redundant\" PSMs keeping only the best scoring PSM "
        "for each unique peptide." << endl;
  }
  
  if(isUniquePeptideRun)
  {
    fullset->weedOutRedundant();
  }
  else
  {
    fullset->merge(xv_test, selectionfdr);
    if(TDC)
    {
       fullset->weedOutRedundantTDC();
	if(VERB > 0)
	{
	  std::cerr << "Target Decoy Competition yielded " << fullset->posSize() << " target PSMs and " 
	  << fullset->negSize() << " decoy PSMs" << std::endl;
	}
    }
  }
  
  Globals::getInstance()->checkTime("merge sets");
  if (VERB > 0 && writeOutput) {
    std:cerr << "Selecting pi_0=" << fullset->getPi0() << endl;
  }
  if (VERB > 0 && writeOutput) {
    cerr << "Calibrating statistics - calculating q values" << endl;
  }
  int foundPSMs = fullset->calcQ(test_fdr);
  Globals::getInstance()->checkTime("calculate q-values");
  fullset->calcPep();
  Globals::getInstance()->checkTime("calculate PEP values");
  if (VERB > 0 && docFeatures && writeOutput) {
    cerr << "For the cross validation sets the average deltaMass are ";
    for (size_t ix = 0; ix < xv_test.size(); ix++) {
      cerr << xv_test[ix].getDOC().getAvgDeltaMass() << " ";
    }
    cerr << "and average pI are ";
    for (size_t ix = 0; ix < xv_test.size(); ix++) {
      cerr << xv_test[ix].getDOC().getAvgPI() << " ";
    }
    cerr << endl;
  }
  if (VERB > 0 && writeOutput) {
    cerr << "New pi_0 estimate on merged list gives " << foundPSMs
        << (reportUniquePeptides ? " peptides" : " PSMs") << " over q="
        << test_fdr << endl;
  }
  if (VERB > 0 && writeOutput) {
    cerr
    << "Calibrating statistics - calculating Posterior error probabilities (PEPs)"
    << endl;
  }
  time_t end;
  time(&end);
  diff = difftime(end, procStart);
  ostringstream timerValues;
  timerValues.precision(4);
  timerValues << "Processing took "
      << ((double)(clock() - procStartClock)) / (double)CLOCKS_PER_SEC;
  timerValues << " cpu seconds or " << diff << " seconds wall time"
      << endl;
  if (VERB > 1 && writeOutput) {
    cerr << timerValues.str();
  }
  if (weightFN.size() > 0) {
    ofstream weightStream(weightFN.data(), ios::out);
    for (unsigned int ix = 0; ix < xval_fold; ++ix) {
      printWeights(weightStream, w[ix]);
    }
    weightStream.close();
  }
  if (resultFN.empty() && writeOutput) {
    normal.print(*fullset);
  } else {
    if(writeOutput){
      ofstream targetStream(((reportUniquePeptides ? "peptides_" : "PSMs_")+resultFN).data(), ios::out);
      normal.print(*fullset, targetStream);
      targetStream.close();
    }
    else
    {
      ofstream targetStream(("PSMs_"+resultFN).data(), ios::out);
      normal.print(*fullset, targetStream);
      targetStream.close();
    }
  }
  if (!decoyOut.empty() && writeOutput) {
    ofstream decoyStream(((reportUniquePeptides ? "peptides_" : "PSMs_")+decoyOut).data(), ios::out);
    shuffled.print(*fullset, decoyStream);
    decoyStream.close();
  }
  else if(!decoyOut.empty()) {
    ofstream decoyStream(("PSMs_"+decoyOut).data(), ios::out);
    shuffled.print(*fullset, decoyStream);
    decoyStream.close();
  }
  // set pi_0 value (to be outputted)
  if(isUniquePeptideRun) {
    pi_0_peptides = fullset->getPi0();
  }
  else {
    pi_0_psms = fullset->getPi0();
    numberQpsms = fullset->getQvaluesBelowLevel(0.01);
  }
}

int Caller::run() {  

  time(&startTime);
  startClock = clock();
  if (VERB > 0) {
    cerr << extendedGreeter();
  }
  // populate tmp input file with cin information if option is enabled
  if(readStdIn){
    ofstream tmpInputFile;
    tmpInputFile.open(xmlInputFN.c_str());
    while(cin) {
      char buffer[1000];
      cin.getline(buffer, 1000);
      tmpInputFile << buffer << endl;
    }
    tmpInputFile.close();
  }
  // Reading input files (pin or temporary file)
  readFiles();
  fillFeatureSets();
  // terminate xercesc
  if(xmlInputFN.size() != 0){
    xercesc::XMLPlatformUtils::Terminate();
  }
  // delete temporary file if reading form stdin
  if(readStdIn){
    remove(xmlInputFN.c_str());
  }
  Globals::getInstance()->checkTime("read input");
  if(VERB > 2){
    std::cerr << "FeatureNames::getNumFeatures(): "<< FeatureNames::getNumFeatures() << endl;
  }
  vector<vector<double> > w(xval_fold,vector<double> (FeatureNames::getNumFeatures()+ 1)), ww;
  int firstNumberOfPositives = preIterationSetup(w);
  if (VERB > 0) {
    cerr << "Estimating " << firstNumberOfPositives << " over q="
        << test_fdr << " in initial direction" << endl;
  }
  // Set up a first guess of w
  time_t procStart;
  clock_t procStartClock = clock();
  time(&procStart);
  double diff = difftime(procStart, startTime);
  if (VERB > 1) cerr << "Reading in data and feature calculation took "
      << ((double)(procStartClock - startClock)) / (double)CLOCKS_PER_SEC
      << " cpu seconds or " << diff << " seconds wall time" << endl;
  if (VERB > 0) {
    cerr << "---Training with Cpos";
    if (selectedCpos > 0) {
      cerr << "=" << selectedCpos;
    } else {
      cerr << " selected by cross validation";
    }
    cerr << ", Cneg";
    if (selectedCneg > 0) {
      cerr << "=" << selectedCneg;
    } else {
      cerr << " selected by cross validation";
    }
    cerr << ", fdr=" << selectionfdr << endl;
  }
  train(w);
  if (!pCheck->validateDirection(w)) {
    fullset.calcScores(w[0]);
  }
  Globals::getInstance()->checkTime("train");
  if (VERB > 0) {
    cerr << "Merging results from " << xv_test.size() << " datasets"
        << endl;
  }

  // calculate psms level probabilities
  
  //PSM probabilities TDA or TDC
  calculatePSMProb(false, &fullset, procStart, procStartClock, w, diff, target_decoy_competition);
  if (xmlOutputFN.size() > 0){
    writeXML_PSMs();
  }
  
  // calculate unique peptides level probabilities WOTE
  if(reportUniquePeptides){
    calculatePSMProb(true, &fullset, procStart, procStartClock, w, diff, target_decoy_competition);
    if (xmlOutputFN.size() > 0){
      writeXML_Peptides();
    }
  }
  // calculate protein level probabilities
  if(calculateProteinLevelProb){

    if (VERB > 0)
    {
      cerr << "\nCalculating protein level probabilities with Fido\n";
      cerr << ProteinProbEstimator::printCopyright();
    }

    protEstimator->initialize(&fullset);
    protEstimator->run();
    if (xmlOutputFN.size() > 0){
      writeXML_Proteins();
    }

  }
  // write output to file
  writeXML();  
  return 0;
}
