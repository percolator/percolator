/*******************************************************************************
 Copyright 2006-2009 Lukas KÃ¤ll <lukas.kall@cbr.su.se>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 *******************************************************************************/
#include <assert.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <algorithm>
#include <map>
#include <set>
#include <vector>
#include <string>
using namespace std;
#include "ResultHolder.h"
#include "DataSet.h"
#include "Normalizer.h"
#include "SetHandler.h"
#include "Scores.h"
#include "Globals.h"



#include "percolator-xml.hxx"



SetHandler::SetHandler() {
  //	charge=c;
  //	norm=Normalizer::getNew();
  n_examples = 0;
  labels = NULL;
  c_vec = NULL;
}

SetHandler::~SetHandler() {
  if (labels) delete[] labels;
  labels = NULL;
  if (c_vec) delete[] c_vec;
  c_vec = NULL;
  for (unsigned int ix = 0; ix < subsets.size(); ix++) {
    if (subsets[ix] != NULL) delete subsets[ix];
    subsets[ix] = NULL;
  }
}

void SetHandler::filelessSetup(const unsigned int numFeatures,
                               const unsigned int numSpectra,
                               const int label) {
  DataSet * pSet = new DataSet();
  pSet->setLabel(label);
  pSet->initFeatureTables(numFeatures, numSpectra);
  subsets.push_back(pSet);
  n_examples = numSpectra;
}

void SetHandler::readFile(const string & fn, const int label) {
  readFile(fn, label, subsets);
  setSet();
}

void SetHandler::readFile(const string& fn, const string& wc,
                          const bool match) {
  readFile(fn, match ? -1 : 1, subsets, wc, match);
  setSet();
}


void SetHandler::push_back_dataset( DataSet * ds ) {
    subsets.push_back(ds);
}


void SetHandler::readFile(const string fn, const int label, vector<
    DataSet *> & sets, const string & wild, const bool match) {
  ifstream fileIn(fn.c_str(), ios::in);
  if (!fileIn) {
    cerr << "Could not open file " << fn << endl;
    exit(-1);
  }
  string line;
  if (!getline(fileIn, line)) {
    cerr << "Could not read file " << fn << endl;
    exit(-1);
  }
  fileIn.close();
  if (line.size() > 1 && line[0] == 'H' && (line[1] == '\t' || line[1]
      == ' ')) {
    if (line.find("SQTGenerator") == string::npos) {
      cerr << "SQT file not generated by SEQUEST: " << fn << endl;
      exit(-1);
    }
    DataSet * pSet = new DataSet();
    pSet->setLabel(label);
    pSet->readSQT(fn, wild, match);
    sets.push_back(pSet);
  } else {
    // we hopefully found a meta file
    string line2;
    ifstream meta(fn.data(), ios::in);
    while (getline(meta, line2)) {
      if (line2.size() > 0 && line2[0] != '#')
      //        cout << "0:" << line2[0] << " 1:" << line2[1] << " e:" << line2[line2.size()-1] << endl;
      readFile(line2, label, sets, wild, match);
    }
    meta.close();
  }
}


void SetHandler::modifyFile(const string& fn, Scores& sc,
                            const string& greet, bool dtaSelect) {
  if (!fn.empty()) {
    modifyFile(fn, subsets, sc, greet, dtaSelect);
  }
}

void SetHandler::modifyFile(const string& fn, vector<DataSet *> & sets,
                            Scores& sc, const string& greet,
                            bool dtaSelect) {
  string line;
  ifstream fileIn(fn.c_str(), ios::in);
  if (sets.size() > 1 && (!fileIn)) {
    cerr << "More than one input file, and file " << fn
        << " that should contain listing to a set of files is not readable"
        << endl;
    exit(-1);
  }
  if (sets.size() > 1 && getline(fileIn, line) && line.size() > 1
      && line[0] == 'H' && line[1] == '\t') {
    cerr << "More than one input file, and file " << fn
        << " do not contain listing to a set of files" << endl;
    exit(-1);
  }
  if (!!fileIn) fileIn.close();

  if (sets.size() == 1) {
    ((DataSet *)sets[0])->modifySQT(fn, &sc, greet, dtaSelect);
    return;
  }
  unsigned int ix = 0;
  fileIn.open(fn.c_str(), ios::in);
  while (getline(fileIn, line)) {
    if (line.size() > 0 && line[0] != '#') {
      ((DataSet *)sets[ix++])->modifySQT(line, &sc, greet, dtaSelect);
    }
  }
  fileIn.close();
}

void SetHandler::print(Scores &test, ostream & myout) {
  vector<ResultHolder> outList(0);
  for (unsigned int setPos = 0; setPos < subsets.size(); setPos++) {
    subsets[setPos]->print(test, outList);
  }
  sort(outList.begin(), outList.end(), greater<ResultHolder> ());

  vector<ResultHolder>::iterator it = outList.begin();

  myout
      << "PSMId\tscore\tq-value\tposterior_error_prob\tpeptide\tproteinIds"
      << endl;
  for (; it != outList.end(); ++it) {
    myout << *it << endl;
  }
}

void SetHandler::generateTrainingSet(const double fdr, const double cpos,
                                     const double cneg, Scores & sc) {
  double tp = 0, fp = 0;
  unsigned int ix = 0;
  examples.clear();
  bool underCutOff = true;
  vector<ScoreHolder>::const_iterator it;
  for (it = sc.begin(); it != sc.end(); it++) {
    if (it->label == -1)
      fp++;
    else
      tp++;
    if (underCutOff && fdr < (fp / (tp + fp))) underCutOff = false;
    if (it->label == -1 || underCutOff) {
      examples.push_back(it->pPSM->features);
      labels[ix] = it->label;
      c_vec[ix++] = (it->label != -1 ? cpos : cneg);
    }
  }
}

PSMDescription * SetHandler::getNext(int& setPos, int& ixPos) {
  PSMDescription * features = subsets[setPos]->getNext(ixPos);
  if (features) return features;
  if (++setPos >= ((signed int)subsets.size())) return NULL;
  ixPos = -1;
  return subsets[setPos]->getNext(ixPos);
}

const double * SetHandler::getFeatures(const int setPos, const int ixPos) const {
  return subsets[setPos]->getFeatures(ixPos);
}

int const SetHandler::getLabel(int setPos) {
  assert(setPos >= 0 && setPos < (signed int)subsets.size());
  return subsets[setPos]->getLabel();
}

void SetHandler::setSet() {
  n_examples = 0;
  int i = 0, j = -1;
  while (getNext(i, j)) {
    n_examples++;
  }
  if (!labels) labels = new double[n_examples];
  if (!c_vec) c_vec = new double[n_examples];
  if (VERB > 3) {
    cerr << "Set up a SetHandler with " << subsets.size()
        << " DataSet:s and " << n_examples << " examples" << endl;
    if (VERB > 4) {
      for (unsigned int i = 0; i < subsets.size(); i++) {
        cerr << "First 10 lines of " << i + 1 << " set with "
            << subsets[i]->getLabel() << " label" << endl;
        subsets[i]->print_10features();
      }
    }
  }
}

void SetHandler::readTab(const string & dataFN, const int setLabel) {
  if (VERB > 1) cerr << "Reading Tab delimetered input from datafile "
      << dataFN << endl;
  ifstream labelStream(dataFN.c_str(), ios::out);
  if (!labelStream) {
    cerr << "Can not open file " << dataFN << endl;
    exit(-1);
  }
  vector<unsigned int> ixs;
  ixs.clear();
  string tmp, line;
  int label;
  unsigned int ix = 0;
  getline(labelStream, tmp); // Id row
  while (true) {
    labelStream >> tmp >> label;
    getline(labelStream, tmp); // read rest of line
    if (!labelStream) break;
    if (label == setLabel) {
      ixs.push_back(ix);
    }
    ++ix;
  }
  labelStream.close();
  ifstream dataStream(dataFN.c_str(), ios::out);
  if (!dataStream) {
    cerr << "Can not open file " << dataFN << endl;
    exit(-1);
  }
  dataStream >> tmp >> tmp;
  dataStream.get(); // removed enumrator, label and tab
  getline(dataStream, line);
  istringstream iss(line);
  int skip = (DataSet::getCalcDoc() ? 2 : 0);
  while (iss.good()) {
    iss >> tmp;
    if (skip-- <= 0) DataSet::getFeatureNames().insertFeature(tmp);
  }
  DataSet * theSet = new DataSet();
  theSet->setLabel(setLabel > 0 ? 1 : -1);
  theSet->readTabData(dataStream, ixs);
  dataStream.close();
  subsets.push_back(theSet);
  setSet();
}

void SetHandler::writeTab(const string &dataFN, const SetHandler& norm,
                          const SetHandler& shuff) {
  ofstream dataStream(dataFN.data(), ios::out);
  dataStream << "SpecId\tLabel\t";
  if (DataSet::getCalcDoc()) dataStream << "RT\tdM\t";
  dataStream << DataSet::getFeatureNames().getFeatureNames(true)
      << "\tPeptide\tProteins" << endl;
  string str;
  for (int setPos = 0; setPos < (signed int)norm.subsets.size(); setPos++) {
    norm.subsets[setPos]->writeTabData(dataStream,
                                       norm.subsets[setPos]->getLabel()
                                           == -1 ? "-1" : "1");
  }
  for (int setPos = 0; setPos < (signed int)shuff.subsets.size(); setPos++) {
    shuff.subsets[setPos]->writeTabData(dataStream,
                                        shuff.subsets[setPos]->getLabel()
                                            == -1 ? "-1" : "1");
  }
  dataStream.close();
}

void SetHandler::readGist(const string & dataFN, const string & labelFN,
                          const int setLabel) {
  if (VERB > 1) cerr << "Reading gist input from datafile " << dataFN
      << " and labels from " << labelFN << endl;
  ifstream labelStream(labelFN.c_str(), ios::out);
  if (!labelStream) {
    cerr << "Can not open file " << labelFN << endl;
    exit(-1);
  }
  vector<unsigned int> ixs;
  ixs.clear();
  string tmp, line;
  int label;
  unsigned int ix = 0;
  getline(labelStream, tmp); // Id row
  while (true) {
    labelStream >> tmp >> label;
    if (!labelStream) break;
    if (label == setLabel) {
      ixs.push_back(ix);
    }
    ++ix;
  }
  labelStream.close();
  ifstream dataStream(dataFN.c_str(), ios::out);
  if (!dataStream) {
    cerr << "Can not open file " << dataFN << endl;
    exit(-1);
  }
  dataStream >> tmp;
  dataStream.get(); // removed enumrator and tab
  getline(dataStream, line);

  istringstream iss(line);
  while (iss.good()) {
    iss >> tmp;
    DataSet::getFeatureNames().insertFeature(tmp);
  }
  DataSet * theSet = new DataSet();
  theSet->setLabel(setLabel > 0 ? 1 : -1);
  theSet->readGistData(dataStream, ixs);
  dataStream.close();
  subsets.push_back(theSet);
  setSet();

}

void SetHandler::gistWrite(const string & fileNameTrunk,
                           const SetHandler& norm, const SetHandler& shuff) {
  string dataFN = fileNameTrunk + ".data";
  string labelFN = fileNameTrunk + ".label";
  ofstream dataStream(dataFN.data(), ios::out);
  ofstream labelStream(labelFN.data(), ios::out);
  labelStream << "SpecId\tLabel" << endl;
  dataStream << "SpecId\t" << DataSet::getFeatureNames().getFeatureNames()
      << endl;
  string str;
  for (int setPos = 0; setPos < (signed int)norm.subsets.size(); setPos++) {
    int ixPos = -1;
    while (norm.subsets[setPos]->getGistDataRow(ixPos, str)) {
      dataStream << str;
      labelStream << str.substr(0, str.find('\t') + 1)
          << (norm.subsets[setPos]->getLabel() == -1 ? -1 : +1) << endl;
    }
  }
  for (int setPos = 0; setPos < (signed int)shuff.subsets.size(); setPos++) {
    int ixPos = -1;
    while (shuff.subsets[setPos]->getGistDataRow(ixPos, str)) {
      dataStream << str;
      labelStream << str.substr(0, str.find('\t') + 1)
          << (shuff.subsets[setPos]->getLabel() == -1 ? -1 : +1) << endl;
    }
  }
  dataStream.close();
  labelStream.close();

}
