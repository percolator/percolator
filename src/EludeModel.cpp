/*******************************************************************************
 Copyright 2006-2012 Lukas KÃ¤ll <lukas.kall@scilifelab.se>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 *****************************************************************************/

#include <vector>
#include <string>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <sstream>
#include <iostream>
#include <fstream>
#include <assert.h>
#ifdef WIN32
#include <float.h>
#define isfinite _finite
#endif

#include "Globals.h"
#include "EludeModel.h"
#include "DataSet.h"
#include "DescriptionOfCorrect.h"

// by default, 3-fold cross validation is used
static unsigned int DEFAULT_K = 3;

// default values for C, gamma and epsilon
// they are used when gType = NO_GRID, except for gamma which is initialized with 1/n
static double INITIAL_C = 5.0;
static double INITIAL_GAMMA = 0.5;
static double INITIAL_EPSILON = 1e-2;

// for gType = FINE_GRID, a coarse grid is used combined with a fine grid
static double COARSE_GRID_GAMMA[] = { pow(2., -15), pow(2., -13),
                                      pow(2., -11), pow(2., -9), pow(2., -7),
                                      pow(2., -5), pow(2., -3), pow(2., -1),
                                      pow(2., 1), pow(2., 3), pow(2., 5) };
static double COARSE_GRID_C[] = { pow(2., -5), pow(2., -3), pow(2., -1),

                                  pow(2., 1), pow(2., 3), pow(2., 5), pow(2.,
                                                                       7),
                                  pow(2., 9), pow(2., 11), pow(2., 13) };
static double COARSE_GRID_EPSILON[] = { INITIAL_EPSILON / 10,
                                        INITIAL_EPSILON, INITIAL_EPSILON
                                            * 10 };
// no of points smaller than the parameter value found using the coarse grid (the fine grid will include NO_POINTS_FINE_GRID*2 for one parameter)
static std::size_t NO_POINTS_FINE_GRID = 7;
// step is give as the exponent of 2 (the actual step value is 2^(STEP_FINE_GRID))
static double STEP_FINE_GRID = 0.25;

// for gType = NORMAL_GRID
static double NORMAL_GRID_GAMMA[] = { pow(2., -8), pow(2., -7), pow(2., -6),
                                      pow(2., -5), pow(2., -4), pow(2., -3),
                                      pow(2., -2), pow(2., -1), pow(2., 0),
                                      pow(2., 1) };
static double NORMAL_GRID_C[] = { pow(2., -2), pow(2., -1), pow(2., 0),
                                  pow(2., 1), pow(2., 2), pow(2., 3), pow(2.,
                                                                       4),
                                  pow(2., 5), pow(2., 6), pow(2., 7) };
static double NORMAL_GRID_EPSILON[] = { INITIAL_EPSILON / 10,
                                        INITIAL_EPSILON, INITIAL_EPSILON
                                            * 10 };

// amino acids alphabet
string RTModel::aaAlphabet = "ACDEFGHIKLMNPQRSTVWY";
string RTModel::inhouseIndexAlphabet = "ACDEFGHIKLMNPQRSTVWY";

//characters indicating post translational modifications in the ms2 file
string RTModel::ptmAlphabet = "#*@";

bool RTModel::doKlammer = false;

///EXPERIMENTAL
// index generated by lqs(aa_features, rts, method='lts', psamp = 900, nsamp = 'best') (R)
float RTModel::Luna_120_index['Z' - 'A' + 1] = { 2.03096f, 0.0f, -0.69783f,
                                                 1.36532f, 1.85552f,
                                                 11.48865f, -1.13960f,
                                                 -7.04092f, 10.57115f, 0.0f,
                                                 -7.19015f, 14.97157f,
                                                 4.76117f, -1.37106f, 0.0f,
                                                 -0.09888f, -0.51064f,
                                                 -6.18977f, -0.51879f,
                                                 0.60516f, 0.0f, 6.16856f,
                                                 5.27152f, 0.0f, 2.67505f,
                                                 0.0f };
float RTModel::TFA_index['Z' - 'A' + 1] = { 5.7081f, 0.0f, -0.3035f, 2.1885f,
                                            2.5696f, 22.3410f, -3.9172f,
                                            -11.8019f, 21.5640f, 0.0f,
                                            -10.9792f, 29.9424f, 7.3929f,
                                            -2.7548f, 0.0f, -1.1636f,
                                            -2.1685f, -8.5213f, -0.3525f,
                                            0.2181f, 0.0f, 15.1851f, 11.1008f,
                                            0.0f, 6.4151f, 0.0f };

// hydrophobicity indices
float
    RTModel::krokhin_index['Z' - 'A' + 1] = { 1.1f, 0.0f, 0.45f, 0.15f, 0.95f,
                                              10.9f, -0.35f, -1.45f, 8.0f,
                                              0.0f, -2.05f, 9.3f, 6.2f, -0.85f,
                                              0.0f, 2.1f, -0.4f, -1.4f, -0.15f,
                                              0.65f, 0.0f, 5.0f, 12.25f, 0.0f,
                                              4.85f, 0.0f };
float RTModel::krokhin100_index['Z' - 'A' + 1] = { 1.0f, 0.0f, 0.1f, 0.15f, 1.0f,
                                                   11.67f, -0.35f, -3.0f,
                                                   7.95f, 0.0f, -3.4f, 9.4f,
                                                   6.25f, -0.95f, 0.0f, 1.85f,
                                                   -0.6f, -2.55f, -0.15f,
                                                   0.65f, 0.0f, 4.7f, 13.35f, 0.0f,
                                                   5.35f, 0.0f };
float
    RTModel::krokhinC2_index['Z' - 'A' + 1] = { 0.5f, 0.0f, 0.2f, 0.4f, 0.0f,
                                                9.5f, 0.15f, -0.2f, 6.6f, 0.0f,
                                                -1.5f, 7.4f, 5.7f, -0.2f, 0.0f,
                                                2.1f, -0.2f, -1.1f, -0.1f,
                                                0.6f, 0.0f, 3.4f, 11.8f, 0.0f,
                                                4.5f, 0.0f };
float RTModel::krokhinTFA_index['Z' - 'A' + 1] = { 1.11f, 0.0f, 0.04f, -0.22f,
                                                   1.08f, 11.34f, -0.35f,
                                                   -3.04f, 7.86f, 0.0f,
                                                   -3.53f, 9.44f, 6.57f,
                                                   -1.44f, 0.0f, 1.62f,
                                                   -0.53f, -2.58f, -0.33f,
                                                   0.48f, 0.0f, 4.86f, 13.12f,
                                                   0.0f, 5.4f, 0.0f };
// negated hessa scale
float RTModel::hessa_index['Z' - 'A' + 1] = { -0.11f, -0.0f, 0.13f, -3.49f,
                                              -2.68f, 0.32f, -0.74f, -2.06f,
                                              0.60f, 0.0f, -2.71f, 0.55f,
                                              0.10f, -2.05f, 0.0f, -2.23f,
                                              -2.36f, -2.58f, -0.84f, -0.52f,
                                              0.0f, 0.31f, -0.30f, 0.0f,
                                              -0.68f, 0.0f };
float RTModel::kytedoolittle_index['Z' - 'A' + 1] = { 1.80f, 0.0f, 2.50f,
                                                      -3.50f, -3.50f, 2.80f,
                                                      -0.40f, -3.20f, 4.50f,
                                                      0.0f, -3.90f, 3.80f,
                                                      1.90f, -3.50f, 0.0f,
                                                      -1.60f, -3.50f, -4.50f,
                                                      -0.80f, -0.70f, 0.0f,
                                                      4.20f, -0.90f, 0.0f,
                                                      -1.30f, 0.0f };
float RTModel::aa_weights['Z' - 'A' + 1] = { 71.0788f, 0.0f, 103.1448f,
                                             115.0886f, 129.1155f, 147.1766f,
                                             57.052f, 137.1412f, 113.1595f,
                                             0.0f, 128.1742f, 113.1595f,
                                             131.1986f, 114.1039f, 0.0f,
                                             97.1167f, 128.1308f, 156.1876f,
                                             87.0782f, 101.1051f, 0.0f,
                                             99.1326f, 186.2133f, 0.0f,
                                             163.1760f, 0.0f };
float RTModel::bulkiness['Z' - 'A' + 1] = { 11.50f, 0.0f, 13.46f, 11.68f,
                                            13.57f, 19.80f, 3.40f, 13.69f,
                                            21.40f, 0.0f, 15.71f, 21.40f,
                                            16.25f, 12.82f, 0.0f, 17.43f,
                                            14.45f, 14.28f, 9.47f, 15.77f,
                                            0.0f, 21.57f, 21.67f, 0.0f, 18.03f,
                                            0.0f };
float RTModel::cornette_index['Z' - 'A' + 1] = { 0.20f, 0.0f, 4.10f, -3.10f,
                                                 -1.80f, 4.40f, 0.00f, 0.50f,
                                                 4.80f, 0.0f, -3.10f, 5.70f,
                                                 4.20f, -0.50f, 0.0f, -2.20f,
                                                 -2.80f, 1.40f, -0.50f,
                                                 -1.90f, 0.0f, 4.70f, 1.0f,
                                                 0.0f, 3.20f, 0.0f };
float RTModel::eisenberg_index['Z' - 'A' + 1] = { 0.62f, 0.0f, 0.29f, -0.90f,
                                                  -0.74f, 1.19f, 0.48f,
                                                  -0.40f, 1.38f, 0.0f, -1.50f,
                                                  1.06f, 0.64f, -0.78f, 0.0f,
                                                  0.12f, -0.85f, -2.53f,
                                                  -0.18f, -0.05f, 0.0f, 1.08f,
                                                  0.81f, 0.0f, 0.26f, 0.0f };
float
    RTModel::meek_index['Z' - 'A' + 1] = { -0.1f, 0.0f, -2.2f, -2.8f, -7.5f,
                                           13.9f, -0.5f, 0.8f, 11.8f, 0.0f,
                                           -3.2f, 10.0f, 7.1f, -1.6f, 0.0f,
                                           8.0f, -2.5f, -4.5f, -3.7f, 1.5f,
                                           0.0f, 3.3f, 18.1f, 0.0f, 8.2f, 0.0f };
/*// conformational preferences of aa
 float RTModel::alpha_helix['Z'-'A'+1] =
 { 1.41, 0.0, 0.66, 0.99, 1.59, 1.16, 0.43, 1.05, 1.09, 0.0, 1.23, 1.34, 1.30, 0.76,
 0.0, 0.34, 1.27, 1.21, 0.57, 0.76, 0.0, 0.90, 1.02, 0.0, 0.74, 0.0};
 float RTModel::beta_sheet['Z'-'A'+1] =
 { 0.72, 0.0, 1.40, 0.39, 0.52, 1.33, 0.58, 0.80,  1.67,  0.0, 0.69, 1.22, 1.14, 0.48,
 0.0, 0.31, 0.98, 0.84, 0.96, 1.17, 0.0, 1.87, 1.35, 0.0, 1.45, 0.0 };*/

// groups of features that can be switched on or off
// last group is experimental and includes no hydrophobic aa, no consec hydophobic aa, no small aa, no
// of consc aliphatic aa, no of c beta branched aa, no of AA, LL, TT
string
    RTModel::feature_groups[NO_FEATURE_GROUPS] = { "inhouse_index",
                                                   "krokhin_index",
                                                   "krokhin100_index",
                                                   "krokhinc2_index",
                                                   "krokhintfa_index",
                                                   "doolittle_index",
                                                   "hessa_index",
                                                   "peptide_size",
                                                   "no_ptms", "ptms",
                                                   "bulkiness",
                                                   "polar_features",
                                                   "hydrophobic_features",
                                                   "aa_features", };
// number of features in each group
int
    RTModel::no_features_per_group[NO_FEATURE_GROUPS] = {
                                                          17,
                                                          17,
                                                          17,
                                                          17,
                                                          17,
                                                          17,
                                                          17,
                                                          1,
                                                          1,
                                                          static_cast<int>(ptmAlphabet.size()),
                                                          1,
                                                          2,
                                                          2,
                                                          static_cast<int>(aaAlphabet.size()) };
// groups of features to be used
// our_index = 1, krokhin = 2, peptide_length = 128, bulkiness = 1024, krdenq = 2048, hfeat = 4096, aa_feat = 8192
//static int DEFAULT_FEATURE_GROUPS = 1 + 2 + 128 + 1024 + 2048 + 4096 + 8192;
static int DEFAULT_FEATURE_GROUPS = 1 + 32 + 128 + 1024 + 2048 + 4096
    + 8192;

RTModel::RTModel() :
  model(NULL), index_model(NULL), c(INITIAL_C), gamma(INITIAL_GAMMA),
      epsilon(INITIAL_EPSILON), stepFineGrid(STEP_FINE_GRID),
      noPointsFineGrid(NO_POINTS_FINE_GRID), calibrationFile(""),
      saveCalibration(false), k(DEFAULT_K), gType(NORMAL_GRID),
      eType(K_FOLD_CV), selected_features(DEFAULT_FEATURE_GROUPS) {
  grids.gridGamma.assign(NORMAL_GRID_GAMMA, NORMAL_GRID_GAMMA
      + sizeof(NORMAL_GRID_GAMMA) / sizeof(NORMAL_GRID_GAMMA[0]));
  grids.gridC.assign(NORMAL_GRID_C, NORMAL_GRID_C + sizeof(NORMAL_GRID_C)
      / sizeof(NORMAL_GRID_C[0]));
  grids.gridEpsilon.assign(NORMAL_GRID_EPSILON, NORMAL_GRID_EPSILON
      + sizeof(NORMAL_GRID_EPSILON) / sizeof(NORMAL_GRID_EPSILON[0]));
  noFeaturesToCalc = 0;
  // compute the total number of features depending on the selected feature groups
  for (int i = 0; i < NO_FEATURE_GROUPS; i++)
    if (selected_features & 1 << i) {
      noFeaturesToCalc += static_cast<std::size_t>(no_features_per_group[i]);
    }
  //cerr << endl; this pollutes Percolator's cerr!
}

RTModel::~RTModel() {
}

// check whether an inhouse hydrophobicity index is to be generated
bool RTModel::calculateIndex() {
  int idx = -1;
  for (int ix = 0; ix < NO_FEATURE_GROUPS; ++ix)
    if (feature_groups[ix].compare("inhouse_index") == 0) {
      idx = ix;
      break;
    }
  if (idx == -1) {
    if (VERB > 1) {
      cerr << "Group inhouse index not found " << endl;
    }
    return false;
  } else if (selected_features & 1 << idx) {
    return true;
  } else {
    return false;
  }
}

size_t RTModel::totalNumRTFeatures() {
  return (doKlammer ? 64 : minimumNumRTFeatures() + aaAlphabet.size());
}

void RTModel::setDoKlammer(const bool switchKlammer) {
  doKlammer = switchKlammer;
}

void RTModel::setSelectFeatures(const int sf) {
  selected_features = sf;
  noFeaturesToCalc = 0;
  for (int i = 0; i < NO_FEATURE_GROUPS; i++)
    if (selected_features & 1 << i) {
      noFeaturesToCalc += static_cast<std::size_t>(no_features_per_group[i]);
    }
}

double RTModel::getNoPtms(string pep) {
  double ptms = 0;
  string::size_type posP = 0;
  while (posP < ptmAlphabet.length()) {
    string::size_type pos = 0;
    while ((pos = pep.find(ptmAlphabet[posP], pos)) != string::npos) {
      pep.replace(pos, 1, "");
      ++pos;
      ++ptms;
    }
    ++posP;
  }
  return ptms;
}

// Functions to compute retention features
// adds 3 features, corresponding to the number of 3 types of ptms in the peptide
double* RTModel::fillPTMFeatures(const string& pep, double* feat) {
  string::size_type pos = ptmAlphabet.size();
  for (; pos--;) {
    feat[pos] = 0.0;
  }
  for (string::const_iterator it = pep.begin(); it != pep.end(); it++) {
    pos = ptmAlphabet.find(*it);
    if (pos != string::npos) {
      feat[pos]++;
    }
  }
  return feat + ptmAlphabet.size();
}

// most and least hydrophobic patches
double* RTModel::amphipathicityHelix(const float* index,
                                     const string& peptide,
                                     double* features) {
  double min = 0.0, max = 0.0, hWindow = 0.0;
  int n = static_cast<int>(peptide.length());
  double cos300, cos400;
  // value to be added to the peptides < 9
  double cst;
  cos300 = cos(300 * M_PI / 180);
  cos400 = cos(400 * M_PI / 180);
  // calculate the average of hydrophobicity of the index
  double avgHydrophobicityIndex = 0.0;
  for (int i = 0; i < 'Z' - 'A' + 1; ++i) {
    avgHydrophobicityIndex += index[i];
  }
  avgHydrophobicityIndex = avgHydrophobicityIndex / static_cast<double>(aaAlphabet.size());
  cst = avgHydrophobicityIndex * (1 + 2 * cos300 + 2 * cos400);
  // if the peptide is too short, use cst
  if (n < 9) {
    *(features++) = cst;
    *(features++) = cst;
  } else {
    // min (maximum) - initialized with the max(min) possible value
    for (unsigned int i = 4; i <= (peptide.length() - 5); ++i) {
      hWindow = index[peptide[i] - 'A'] + (cos300 * (index[peptide[i - 3]
          - 'A'] + index[peptide[i + 3] - 'A'])) + (cos400
          * (index[peptide[i - 4] - 'A'] + index[peptide[i + 4] - 'A']));
      if (i == 4) {
        min = hWindow;
        max = hWindow;
      } else {
        if (hWindow < min) {
          min = hWindow;
        }
        if (hWindow > max) {
          max = hWindow;
        }
      }
    }
    *(features++) = min;
    *(features++) = max;
  }
  return features;
}

// bulkiness
double RTModel::bulkinessSum(const string& peptide) {
  double sum = 0.0;
  string::const_iterator token = peptide.begin();
  for (; token != peptide.end(); ++token) {
    sum += bulkiness[*token - 'A'];
  }
  return sum;
}

// hydrophobic moment (angle = 100 for helices, = 180 for sheets)
double* RTModel::hydrophobicMoment(const float* index,
                                   const string& peptide,
                                   const double angleDegrees, const int w,
                                   double* features) {
  double sum1 = 0.0, sum2 = 0.0;
  int lengthPeptide = static_cast<int>(peptide.length());
  double minHMoment, maxHMoment, hMoment;
  // calculate the angle in radians
  double angle = angleDegrees * M_PI / 180;
  for (std::size_t i = 0; i < min(lengthPeptide, w); ++i) {
    sum1 += index[peptide[i] - 'A'] * sin(static_cast<double>(i + 1) * angle);
    sum2 += index[peptide[i] - 'A'] * cos(static_cast<double>(i + 1) * angle);
  }
  hMoment = sqrt((sum1 * sum1) + (sum2 * sum2));
  minHMoment = hMoment;
  maxHMoment = hMoment;
  if (lengthPeptide > w) {
    for (std::size_t i = 1; i <= lengthPeptide - w; ++i) {
      sum1 = 0.0;
      sum2 = 0.0;
      for (std::size_t j = 0; j < w; j++) {
        sum1 += index[peptide[i + j] - 'A'] * sin(static_cast<double>(j + 1) * angle);
        sum2 += index[peptide[i + j] - 'A'] * cos(static_cast<double>(j + 1) * angle);
      }
      hMoment = sqrt((sum1 * sum1) + (sum2 * sum2));
      if (hMoment > maxHMoment) {
        maxHMoment = hMoment;
      }
      if (hMoment < minHMoment) {
        minHMoment = hMoment;
      }
    }
  }
  *(features++) = minHMoment;
  *(features++) = maxHMoment;
  return features;
}

// function used by percolator
void RTModel::fillFeaturesAllIndex(const string& pep, double* features) {
  // calculate the number of posttranslational modifications
  unsigned int ptms = 0;
  string peptide = pep;
  string::size_type posP = 0;
  while (posP < ptmAlphabet.length()) {
    string::size_type pos = 0;
    while ((pos = peptide.find(ptmAlphabet[posP], pos)) != string::npos) {
      peptide.replace(pos, 1, "");
      ++pos;
      ++ptms;
    }
    ++posP;
  }
  if (doKlammer) {
    // Klammer et al. features
    features = fillAAFeatures(aaAlphabet, peptide, features);
    features = fillAAFeatures(aaAlphabet, peptide.substr(0, 1), features);
    features = fillAAFeatures(aaAlphabet, peptide.substr(peptide.size()
        - 2, 1), features);
    char Ct = peptide[peptide.size() - 1];
    *(features++) = ((Ct == 'K' || Ct == 'R') ? 1.0 : 0.0);
    *(features++) = static_cast<double>(peptide.size());
    *(features++) = indexSum(aa_weights, peptide) + 1.0079 + 17.0073; //MV
  } else {
    // fill in the features characteristic to each of the three hydrophobicity indices
    features = fillFeaturesIndex(peptide, krokhin_index, features);
    features = fillFeaturesIndex(peptide, krokhin100_index, features);
    features = fillFeaturesIndex(peptide, krokhinTFA_index, features);
    *(features++) = static_cast<double>(peptide.size());
    *(features++) = (double)ptms;
    // fill all the aa features
    features = fillAAFeatures(aaAlphabet, peptide, features);
  }
}

// calculate the sum of hydrophobicities of all aa in the peptide
double RTModel::indexSum(const float* index, const string& peptide) {
  double sum = 0.0;
  string::const_iterator token = peptide.begin();
  for (; token != peptide.end(); ++token) {
    sum += index[*token - 'A'];
  }
  return sum;
}

// calculate the average of hydrophobicities of all aa in the peptide
double RTModel::indexAvg(const float* index, const string& peptide) {
  double sum = 0.0;
  string::const_iterator token = peptide.begin();
  for (; token != peptide.end(); ++token) {
    sum += index[*token - 'A'];
  }
  return sum / (double)peptide.size();
}

// calculate the sum of hydrophobicities of neighbours of R(Argenine) and K (Lysine)
double RTModel::indexNearestNeigbourPos(const float* index,
                                        const string& peptide) {
  double sum = 0.0;
  for (unsigned int ix = 0; ix < peptide.size(); ++ix) {
    if (peptide[ix] == 'R' || peptide[ix] == 'K') {
      if (ix > 0) {
        sum += max(0.0f, index[peptide[ix - 1] - 'A']);
      }
      if (ix < peptide.size() - 1) {
        sum += max(0.0f, index[peptide[ix + 1] - 'A']);
      }
    }
  }
  return sum;
}

// calculate the sum of hydrophobicities of neighbours of D(Aspartate) and E(Glutamate)
double RTModel::indexNearestNeigbourNeg(const float* index,
                                        const string& peptide) {
  double sum = 0.0;
  for (unsigned int ix = 0; ix < peptide.size(); ++ix) {
    if (peptide[ix] == 'D' || peptide[ix] == 'E') {
      if (ix > 0) {
        sum += max(0.0f, index[peptide[ix - 1] - 'A']);
      }
      if (ix < peptide.size() - 1) {
        sum += max(0.0f, index[peptide[ix + 1] - 'A']);
      }
    }
  }
  return sum;
}

// hydrophobicity of the n-terminus
inline double RTModel::indexN(const float* index, const string& peptide) {
  return index[peptide[0] - 'A'];
}

// hydrophobicity of the c-terminus
inline double RTModel::indexC(const float* index, const string& peptide) {
  return index[peptide[peptide.size() - 1] - 'A'];
}

// product between hydrophobicity of n- and c- terminus
inline double RTModel::indexNC(const float* index, const string& peptide) {
  double n = max(0.0, indexN(index, peptide));
  double c = max(0.0, indexC(index, peptide));
  return n * c;
}

// the most and least hydrophobic windows
double* RTModel::indexPartialSum(const float* index,
                                 const string& peptide, const size_t win,
                                 double* features) {
  double sum = 0.0;
  size_t window = min(win, peptide.size() - 1);
  string::const_iterator lead = peptide.begin(), lag = peptide.begin();
  for (; lead != (peptide.begin() + static_cast<long int>(window)); ++lead) {
    sum += index[*lead - 'A'];
  }
  double minS = sum, maxS = sum;
  for (; lead != peptide.end(); ++lead, ++lag) {
    sum += index[*lead - 'A'];
    sum -= index[*lag - 'A'];
    minS = min(sum, minS);
    maxS = max(sum, maxS);
  }
  *(features++) = maxS;
  *(features++) = minS;
  return features;
}

// adds 20 features, each including the number of an aa in the peptide
double* RTModel::fillAAFeatures(const string& alphabet, const string& pep,
                                double* feat) {
  // Overall amino acid composition features
  string::size_type pos = alphabet.size();
  for (; pos--;) {
    feat[pos] = 0.0;
  }
  for (string::const_iterator it = pep.begin(); it != pep.end(); it++) {
    pos = alphabet.find(*it);
    if (pos != string::npos) {
      feat[pos]++;
    }
  }
  return feat + alphabet.size();
}

// calculate the number of hydrophobic aa
double RTModel::noHydrophobicAA(const string& peptide) {
  string hydrophobicAA = "AILMFWYVC";
  //string hydrophobicAA = "VILMFWCAYHTSPGRK";
  double noOccurences = 0.0;
  for (unsigned int ix = 0; ix < peptide.size(); ++ix)
    if (hydrophobicAA.find(peptide[ix]) != string::npos) {
      noOccurences++;
    }
  //cout << "No hydrophobic aa " << noOccurences << endl;
  return noOccurences;
}

// calculate the number of consecutive hydrophobic aa
double RTModel::noConsecHydrophobicAA(const string& peptide) {
  string hydrophobicAA = "AILMFWYVC";
  double noOccurences = 0.0;
  size_t isH1, isH2;
  for (unsigned int ix = 0; ix < (peptide.size() - 1); ++ix) {
    // are the current aa and his neighbour hydrophobic?
    isH1 = hydrophobicAA.find(peptide[ix]);
    isH2 = hydrophobicAA.find(peptide[ix + 1]);
    if ((isH1 != string::npos) && (isH2 != string::npos)) {
      noOccurences++;
    }
  }
  //cout << "No consec hydrophobic aa " << noOccurences << endl;
  return noOccurences;
}

// calculate the number of polar aa (R,K,D,E,N,Q)
double RTModel::noPolarAA(const string& peptide) {
  string polarAA = "RKDENQ";
  double noOccurences = 0.0;
  for (unsigned int ix = 0; ix < peptide.size(); ++ix)
    if (polarAA.find(peptide[ix]) != string::npos) {
      noOccurences++;
    }
  return noOccurences;
}

// calculate the number of consecutive occurences of (R,K,D,E,N,Q)
double RTModel::noConsecPolarAA(const string& peptide) {
  double noOccurences = 0.0;
  string polarAA = "RKDENQ";
  size_t isAA1, isAA2;
  for (unsigned int ix = 0; ix < (peptide.size() - 1); ++ix) {
    // are the current aa and his neighbour one of RKDENQ?
    isAA1 = polarAA.find(peptide[ix]);
    isAA2 = polarAA.find(peptide[ix + 1]);
    if ((isAA1 != string::npos) && (isAA2 != string::npos)) {
      noOccurences++;
    }
  }
  return noOccurences;
}

// fill the 8 experimental features
double* RTModel::fillHydrophobicFeatures(const string& peptide,
                                         double* features) {
  *(features++) = noHydrophobicAA(peptide);
  *(features++) = noConsecHydrophobicAA(peptide);
  return features;
}

double* RTModel::fillPolarFeatures(const string& peptide, double* features) {
  *(features++) = noPolarAA(peptide);
  *(features++) = noConsecPolarAA(peptide);
  return features;
}

// calculate the sum of squared differences in hydrophobicities between neighbours
// this will be an index features
double RTModel::indexSumSquaredDiff(const float* index,
                                    const string& peptide) {
  double sSquaredDiff = 0.0;
  double diff;
  for (unsigned int ix = 0; ix < (peptide.size() - 1); ++ix) {
    diff = index[peptide[ix + 1] - 'A'] - index[peptide[ix] - 'A'];
    sSquaredDiff += diff * diff;
  }
  return sSquaredDiff / double(peptide.size());
}

double* RTModel::fillFeaturesIndex(const string& peptide,
                                   const float* index, double* features) {
  *(features++) = indexSum(index, peptide);
  *(features++) = indexAvg(index, peptide);
  *(features++) = indexN(index, peptide);
  *(features++) = indexC(index, peptide);
  *(features++) = indexNearestNeigbourPos(index, peptide);
  *(features++) = indexNearestNeigbourNeg(index, peptide);
  features = indexPartialSum(index, peptide, 5, features);
  features = indexPartialSum(index, peptide, 2, features);
  features = amphipathicityHelix(index, peptide, features);
  features = hydrophobicMoment(index, peptide, 100, 11, features);
  features = hydrophobicMoment(index, peptide, 180, 11, features);
  *(features++) = indexSumSquaredDiff(index, peptide);
  return features;
}

void RTModel::calcRetentionFeatures(PSMDescription* psm) {

  string pep = psm->getPeptideSequence();
  double* features = psm->getRetentionFeatures();
  // if there is memory allocated
  if (psm->getRetentionFeatures()) {
    if (selected_features & 1 << 0) {
      features = fillFeaturesIndex(pep, our_index, features);
      //cout << "our_index" << endl;
    }
    if (selected_features & 1 << 1) {
      features = fillFeaturesIndex(pep, krokhin_index, features);
      //cout << "krokhin_index" << endl;
    }
    if (selected_features & 1 << 2) {
      features = fillFeaturesIndex(pep, krokhin100_index, features);
      //cout << "krokhin100_index" << endl;
    }
    if (selected_features & 1 << 3) {
      features = fillFeaturesIndex(pep, krokhinC2_index, features);
      //cout << "krokhinC2_index" << endl;
    }
    if (selected_features & 1 << 4) {
      features = fillFeaturesIndex(pep, krokhinTFA_index, features);
      //cout << "krokhinTFA" << endl;
    }
    if (selected_features & 1 << 5) {
      features = fillFeaturesIndex(pep, kytedoolittle_index, features);
      //cout << "kyte doolittle" << endl;
    }
    if (selected_features & 1 << 6) {
      features = fillFeaturesIndex(pep, hessa_index, features);
      //cout << "hessa_index" << endl;
    }
    if (selected_features & 1 << 7) {
      *(features++) = static_cast<double>(pep.size());
      //cout << "length" << endl;
    }
    if (selected_features & 1 << 8) {
      *(features++) = getNoPtms(pep);
      //cout << "no ptms" << getNoPtms(pep) << endl;
    }
    // number of each type of ptm
    if (selected_features & 1 << 9) {
      features = fillPTMFeatures(pep, features);
      //cout << "ptms" << endl;
    }
    // bulkiness
    if (selected_features & 1 << 10) {
      *(features++) = bulkinessSum(pep);
      //cout << "bulkiness" << endl;
    }
    // no of consecutive KRDENQ
    if (selected_features & 1 << 11) {
      features = fillPolarFeatures(pep, features);
      //cout << "KRDENQ" << endl;
    }
    // experimental
    if (selected_features & 1 << 12) {
      features = fillHydrophobicFeatures(pep, features);
      //cout << "Hydrophobicity " << endl;
    }
    // amino acids
    if (selected_features & 1 << 13) {
      features = fillAAFeatures(aaAlphabet, pep, features);
      //cout << "AA" << endl;
    }
    //cout << "Calculated " << n << " features" << endl;
  } else {
    cout << "Pointer not allocated" << endl;
  }
  //cout << psm << endl;
}

// calculate the retention features for a vector of PSMs
void RTModel::calcRetentionFeatures(vector<PSMDescription*> &psms) {
  vector<PSMDescription*>::iterator it;
  if (VERB > 2) {
    cerr << endl << "Computing retention features..." << endl;
  }
  for (it = psms.begin(); it != psms.end(); ++it) {
    calcRetentionFeatures(*it);
  }
  if (VERB > 2) {
    cerr << "Done. " << endl;
  }
}

// save an svm model in the global variable model
void RTModel::copyModel(svm_model* from) {
  // destroy an existant model
  if (model != NULL) {
    svm_destroy_model(model);
  }
  model = (svm_model*)malloc(sizeof(svm_model));
  model->param = from->param;
  model->nr_class = from->nr_class;
  model->l = from->l; // total #SV
  // _DENSE_REP
  model->SV = (svm_node*)malloc(sizeof(svm_node) * static_cast<std::size_t>(model->l));
  for (int i = 0; i < model->l; ++i) {
    model->SV[i].dim = from->SV[i].dim;
    model->SV[i].values = (double*)malloc(sizeof(double)
        * static_cast<std::size_t>(model->SV[i].dim));
    memcpy(model->SV[i].values, from->SV[i].values, sizeof(double)
        * static_cast<std::size_t>(model->SV[i].dim));
  }
  model->sv_coef = (double**)malloc(sizeof(double*)
      * static_cast<std::size_t>(model->nr_class - 1));
  for (int i = 0; i < model->nr_class - 1; ++i) {
    model->sv_coef[i] = (double*)malloc(sizeof(double) * static_cast<std::size_t>(model->l));
    memcpy(model->sv_coef[i], from->sv_coef[i], sizeof(double)
        * static_cast<std::size_t>(model->l));
  }
  int n = model->nr_class * (model->nr_class - 1) / 2;
  if (from->rho) {
    model->rho = (double*)malloc(sizeof(double) * static_cast<std::size_t>(n));
    memcpy(model->rho, from->rho, sizeof(double) * static_cast<std::size_t>(n));
  } else {
    model->rho = NULL;
  }
  if (from->probA) {
    model->probA = (double*)malloc(sizeof(double) * static_cast<std::size_t>(n));
    memcpy(model->probA, from->probA, sizeof(double) * static_cast<std::size_t>(n));
  } else {
    model->probA = NULL;
  }
  if (from->probB) {
    model->probB = (double*)malloc(sizeof(double) * static_cast<std::size_t>(n));
    memcpy(model->probB, from->probB, sizeof(double) * static_cast<std::size_t>(n));
  } else {
    model->probB = NULL;
  }
  assert(from->label == NULL);
  assert(from->nSV == NULL);
  // for classification only
  model->label = NULL; // label of each class (label[k])
  model->nSV = NULL; // number of SVs for each class (nSV[k])
  // nSV[0] + nSV[1] + ... + nSV[k-1] = l
  // XXX
  model->free_sv = 1; // 1 if svm_model is created by svm_load_mode                        // 0 if svm_model is created by svm_train
}

// select the first n features from; return the corresponding code
int RTModel::getSelect(int sel_features, int max, size_t* finalNumFeatures) {
  int noFeat = 0;
  int retValue = 0;
  for (int i = 0; i < NO_FEATURE_GROUPS; i++)
    // if this feature was selected and if adding it does not exceed the allowed no of features, then add it
    if ((sel_features & 1 << i) && ((noFeat + no_features_per_group[i])
        <= max)) {
      retValue += (int)pow(2., i);
      noFeat += no_features_per_group[i];
    }
  (*finalNumFeatures) = static_cast<std::size_t>(noFeat);
  return retValue;
}

// train the SVM
void RTModel::trainRetention(vector<PSMDescription*>& trainset,
                             const double C, const double gamma,
                             const double epsilon, int noPsms) 
{
  // initialize the parameters of the SVM
  svm_parameter param;
  param.svm_type = EPSILON_SVR;
  param.kernel_type = RBF;
  //param.gamma = 1/(double)noPsms*gamma;
  param.gamma = gamma;
  param.coef0 = 0;
  param.nu = 0.5;
  param.cache_size = 300;
  param.C = C;
  param.eps = epsilon; //1e-3;
  param.p = 0.1;
  param.shrinking = 1;
  param.probability = 0;
  param.nr_weight = 0;
  param.weight_label = NULL;
  param.weight = NULL;
  // initialize a SVM problem
  svm_problem data;
  data.l = trainset.size();
  data.x = new svm_node[data.l];
  data.y = new double[data.l];
  for (size_t ix1 = 0; ix1 < trainset.size(); ix1++) {
    data.x[ix1].values = trainset[ix1]->getRetentionFeatures();
    data.x[ix1].dim = static_cast<int>(noFeaturesToCalc);
    data.y[ix1] = trainset[ix1]->getRetentionTime();
  }
  // build a model by training the SVM on the given training set
  char const *err_msg = svm_check_parameter(&data, &param);
  if (err_msg != NULL) {
    delete[] data.x;
    delete[] data.y;
    ostringstream temp;
    temp << "Error : Incorrect parameters for the SVR." << endl
	 << err_msg << endl << "Execution aborted."<< endl;
    throw MyException(temp.str());
  }
  svm_model* m = svm_train(&data, &param);
  // save the model in the current object
  copyModel(m);
  delete[] data.x;
  delete[] data.y;
  svm_destroy_model(m);
}

// old function to train a SVR (used by percolator)
void RTModel::trainRetention(vector<PSMDescription*>& psms) {
  // Train retention time regressor
  size_t test_frac = 4u;
  if (psms.size() > test_frac * 10u) {
    // If we got enough data, calibrate gamma and C by leaving out a testset
    std::vector<PSMDescription*> train, test;
    for (size_t ix = 0; ix < psms.size(); ++ix) {
      if (ix % test_frac == 0) {
        test.push_back(psms[ix]);
      } else {
        train.push_back(psms[ix]);
      }
    }
    double sizeFactor = ((double)train.size()) / ((double)psms.size());
    double bestRms = 1e100;
    double gammaV[3] = { gamma / 2, gamma, gamma * 2 };
    double cV[3] = { c / 2. / sizeFactor, c / sizeFactor, c * 2.
        / sizeFactor };
    double epsilonV[3] = { epsilon / 2, epsilon, epsilon * 2 };
    for (double* gammaNow = &gammaV[0]; gammaNow != &gammaV[3]; gammaNow++) {
      for (double* cNow = &cV[0]; cNow != &cV[3]; cNow++) {
        for (double* epsilonNow = &epsilonV[0]; epsilonNow != &epsilonV[3]; epsilonNow++) {
          trainRetention(train,
                         *cNow,
                         (*gammaNow) / ((double)psms.size()),
                         *epsilonNow,
                         static_cast<int>(train.size()));
          double rms = testRetention(test);
          if (rms < bestRms) {
            c = *cNow;
            gamma = *gammaNow;
            epsilon = *epsilonNow;
            bestRms = rms;
          }
        }
      }
    }
    // Compensate for the difference in size of the training sets
    c = sizeFactor * c;
    // cerr << "CV selected gamma=" << gamma << " and C=" << c << endl;
  }
  trainRetention(psms,
                 c,
                 gamma / ((double)psms.size()),
                 epsilon,
                 static_cast<int>(psms.size()));
}

// perform k-validation and return as estimate of the prediction error CV = 1/k (sum(PE(k))), where PE(k)=(sum(yi - yi_pred)^2)/size
double RTModel::computeKfoldCV(const vector<PSMDescription*> & psms,
                               const double gamma, const double epsilon,
                               const double c) {
  vector<PSMDescription*> train, test;
  unsigned int noPsms;
  // sum of prediction errors
  double sumPEs, PEk;
  noPsms = static_cast<unsigned int>(psms.size());
  sumPEs = 0;
  if (VERB > 2) {
    cerr << k << " fold cross validation..." << endl;
  }
  for (unsigned int i = 0; i < k; ++i) {
    train.clear();
    test.clear();
    // get training and testing sets
    for (unsigned int j = 0; j < noPsms; ++j) {
      if ((j % k) == i) {
        test.push_back(psms[j]);
      } else {
        train.push_back(psms[j]);
      }
    }
    trainRetention(train, c, gamma, epsilon, static_cast<int>(noPsms))  ;
    PEk = testRetention(test);
    sumPEs += PEk;
  }
  if (VERB > 2) {
    cerr << "Done." << endl;
  }
  return (sumPEs / (double)k);
}

// simple evaluation; just divide the data in 4 parts, train on three of them and test on the 4th; return the ms of diff
double RTModel::computeSimpleEvaluation(
                                        const vector<PSMDescription*> & psms,
                                        const double gamma,
                                        const double epsilon,
                                        const double c) {
  vector<PSMDescription*> train, test;
  unsigned int noPsms;
  double ms;
  // how many parts will the data be split in
  size_t test_frac;
  test_frac = 4u;
  noPsms = static_cast<unsigned int>(psms.size());
  // give a warning if there is little data
  if ((VERB >= 2) && (noPsms < test_frac * 10u)) {
    cerr << "Warning: very little data to calibrate parameters (just "
        << noPsms << "), parameter values may be unreliable" << endl;
  }
  if (VERB > 2) {
    cerr << "Simple evaluation..." << endl;
  }
  // build train and test set
  for (size_t i = 0; i < noPsms; ++i) {
    if (i % test_frac == 0) {
      test.push_back(psms[i]);
    } else {
      train.push_back(psms[i]);
    }
  }
  // train the model and test it
  trainRetention(train, c, gamma, epsilon, static_cast<int>(noPsms));
  ms = testRetention(test);
  if (VERB > 2) {
    cerr << "Done." << endl;
  }
  return ms;
}

// train the Support Vector Regressor
void RTModel::trainSVM(vector<PSMDescription*> & psms) {
  int noPsms = static_cast<int>(psms.size());
  if (VERB >= 2) {
    cerr << endl << "Training the SVR model..." << endl;
  }
  // if no parameter calibration is to be performed, then just use the defaults to train the model (except for gamma = 1/n)
  if (gType == NO_GRID) {
    gamma = 1.0 / (double)noPsms;
    trainRetention(psms, c, gamma, epsilon, noPsms);
    if (VERB >= 2) {
      cerr << "Done. " << endl;
    }
    return;
  }
  // calibrate parameters using the grid (if gType = FINE_GRID, this will be followed by a fine grid search)
  ofstream calFile;
  double gamma = 0.0, epsilon = 0.0, c = 0.0;
  double bestError = 1e100, error;
  vector<double>::iterator it1, it2, it3;
  int totalIterations = static_cast<int>(grids.gridGamma.size() * grids.gridC.size()
      * grids.gridEpsilon.size());
  int step = 0;
  if (saveCalibration) {
    calFile.open(calibrationFile.c_str(), ios::out);
    calFile << "gamma\tC\tepsilon\terror\n";
  }
  if (VERB > 2) {
    cerr << "Calibrating (gamma, epsilon, c)..." << endl;
    cerr << "------------------------------" << endl;
  }
  // grid search to calibrate parameters
  for (it1 = grids.gridGamma.begin(); it1 != grids.gridGamma.end(); ++it1) {
    for (it2 = grids.gridC.begin(); it2 != grids.gridC.end(); ++it2) {
      for (it3 = grids.gridEpsilon.begin(); it3 != grids.gridEpsilon.end(); ++it3) {
        ++step;
        if (VERB > 2) {
          cerr << "Step " << step << " / " << totalIterations << endl;
          cerr << "Evaluate = (gamma, C, epsilon) = (" << (*it1) << ", "
              << (*it2) << ", " << (*it3) << ")" << endl;
        }
        if (eType == SIMPLE_EVAL) {
          error = computeSimpleEvaluation(psms, (*it1), (*it3), (*it2));
        } else {
          error = computeKfoldCV(psms, (*it1), (*it3), (*it2));
        }
        if (VERB > 2) {
          cerr << "Error = " << error << endl;
        }
        // save info to the calibration file
        if (saveCalibration) {
          calFile << (*it1) << "\t" << (*it2) << "\t" << (*it3) << "\t"
              << error << "\n";
        }
        if (error < bestError) {
          c = (*it2);
          gamma = (*it1);
          epsilon = (*it3);
          bestError = error;
        }
        if (VERB > 2) {
          cerr << endl;
        }
      }
    }
  }
  if (VERB >= 2) {
    cerr << "Done." << endl;
  }
  // if fine grid is to be perform, then build the fine grid according to parameters and calibrate gamma and
  if (gType == FINE_GRID) {
    vector<double> fGridC, fGridGamma;
    double offset;
    if (saveCalibration) {
      calFile << "--------------------------------\n";
    }
    if (VERB > 2) cerr << endl
        << "Calibration via fine grid starting from (gamma, epsilon, c) = ("
        << gamma << ", " << epsilon << ", " << c << ") with Error = "
        << bestError << endl;
    // define the fine grid
    for (int i = -1*static_cast<int>(noPointsFineGrid); (i < 0) || static_cast<unsigned int>(i) <= noPointsFineGrid; ++i) {
      offset = pow(2., stepFineGrid * i);
      fGridC.push_back(c * offset);
      fGridGamma.push_back(gamma * offset);
    }
    totalIterations = static_cast<int>(fGridGamma.size() * fGridC.size());
    step = 0;
    // fine grid search to calibrate parameters
    for (it1 = fGridGamma.begin(); it1 != fGridGamma.end(); ++it1) {
      for (it2 = fGridC.begin(); it2 != fGridC.end(); ++it2) {
        ++step;
        if (VERB > 2) {
          cerr << endl << "Step " << step << " / " << totalIterations
              << endl;
          cerr << "Evaluate (gamma, c, epsilon) = " << (*it1) << ", "
              << (*it2) << ", " << epsilon << ")" << endl;
        }
        if (eType == SIMPLE_EVAL) {
          error = computeSimpleEvaluation(psms, (*it1), epsilon, (*it2));
        } else {
          error = computeKfoldCV(psms, (*it1), epsilon, (*it2));
        }
        if (VERB > 2) {
          cerr << "Error = " << error << endl;
        }
        // save info to the calibration file
        if (saveCalibration) {
          calFile << (*it1) << "\t" << (*it2) << "\t" << (*it3) << "\t"
              << error << "\n";
        }
        if (error < bestError) {
          c = (*it2);
          gamma = (*it1);
          bestError = error;
        }
      }
    }
  }
  if (VERB > 2) {
    cerr << "------------------------------" << endl;
    cerr << "Final parameters are (gamma, c, epsilon) = (" << gamma
        << ", " << c << ", " << epsilon << ") with error = " << bestError
        << endl;
  }
  // in the final step train the model on all available data using the best parameters found so far
  if (VERB > 3) {
    cerr << endl << "Performing final training..." << endl;
  }
  trainRetention(psms, c, gamma, epsilon, noPsms);
  if (VERB > 3) {
    cerr << "Done." << endl;
  }
  if (saveCalibration) {
    calFile.close();
    if (VERB > 3) {
      cerr << "Calibration details were saved to " << calibrationFile
          << endl;
    }
  }
}

// test the svm on the given test set
double RTModel::testRetention(vector<PSMDescription*>& testset) {
  double rms = 0.0;
  double estimatedRT;
  for (size_t ix1 = 0; ix1 < testset.size(); ix1++) {
    estimatedRT = estimateRT(testset[ix1]->getRetentionFeatures());
    double diff = estimatedRT - testset[ix1]->getRetentionTime();
    rms += diff * diff;
  }
  return rms / static_cast<double>(testset.size());
}

// estimate the retention time using the svm model
double RTModel::estimateRT(double* features) {
  double predicted_value;
  svm_node node;
  node.values = features;
  node.dim = static_cast<int>(noFeaturesToCalc);
  predicted_value = svm_predict(model, &node);
  if (!isfinite(predicted_value)) {
    predicted_value = 0.0;
  }
  return predicted_value;
}

/*
 * EXPERIMENTAL - try to train a hydrophobicity scale using a linear SVR; the weights will give the "hydrophobicity" of each aa
 * Since it is just an experimental try, everything is put in just one function
 * We return the new index
 */
void RTModel::copyIndexModel(svm_model* from) {
  // destroy an existant model
  if (index_model != NULL) {
    svm_destroy_model(index_model);
  }
  index_model = (svm_model*)malloc(sizeof(svm_model));
  index_model->param = from->param;
  index_model->nr_class = from->nr_class;
  index_model->l = from->l; // total #SV
  // _DENSE_REP
  index_model->SV = (svm_node*)malloc(sizeof(svm_node) * static_cast<std::size_t>(index_model->l));
  for (int i = 0; i < index_model->l; ++i) {
    index_model->SV[i].dim = from->SV[i].dim;
    index_model->SV[i].values = (double*)malloc(sizeof(double)
        * static_cast<std::size_t>(index_model->SV[i].dim));
    memcpy(index_model->SV[i].values, from->SV[i].values, sizeof(double)
        * static_cast<std::size_t>(index_model->SV[i].dim));
  }
  index_model->sv_coef = (double**)malloc(sizeof(double*)
      * static_cast<std::size_t>(index_model->nr_class - 1));
  for (int i = 0; i < index_model->nr_class - 1; ++i) {
    index_model->sv_coef[i] = (double*)malloc(sizeof(double)
        * static_cast<std::size_t>(index_model->l));
    memcpy(index_model->sv_coef[i], from->sv_coef[i], sizeof(double)
        * static_cast<std::size_t>(index_model->l));
  }
  int n = index_model->nr_class * (index_model->nr_class - 1) / 2;
  if (from->rho) {
    index_model->rho = (double*)malloc(sizeof(double) * static_cast<std::size_t>(n));
    memcpy(index_model->rho, from->rho, sizeof(double) * static_cast<std::size_t>(n));
  } else {
    index_model->rho = NULL;
  }
  if (from->probA) {
    index_model->probA = (double*)malloc(sizeof(double) * static_cast<std::size_t>(n));
    memcpy(index_model->probA, from->probA, sizeof(double) * static_cast<std::size_t>(n));
  } else {
    index_model->probA = NULL;
  }
  if (from->probB) {
    index_model->probB = (double*)malloc(sizeof(double) * static_cast<std::size_t>(n));
    memcpy(index_model->probB, from->probB, sizeof(double) * static_cast<std::size_t>(n));
  } else {
    index_model->probB = NULL;
  }
  assert(from->label == NULL);
  assert(from->nSV == NULL);
  // for classification only
  index_model->label = NULL; // label of each class (label[k])
  index_model->nSV = NULL; // number of SVs for each class (nSV[k])
  // nSV[0] + nSV[1] + ... + nSV[k-1] = l
  // XXX
  index_model->free_sv = 1; // 1 if svm_model is created by svm_load_mode
}

// train a linear SVR with the given parameters
void RTModel::trainIndexRetention(vector<PSMDescription*>& trainset,
                                  const double C, const double epsilon) {
  svm_parameter param;
  param.svm_type = EPSILON_SVR;
  param.kernel_type = LINEAR;
  param.cache_size = 300;
  param.eps = epsilon; //1e-3;
  param.C = C;
  param.nr_weight = 0;
  param.weight_label = NULL;
  param.weight = NULL;
  param.p = 0.1;
  param.shrinking = 1;
  param.probability = 0;
  // initialize a SVM problem
  svm_problem data;
  data.l = trainset.size();
  data.x = new svm_node[data.l];
  data.y = new double[data.l];
  for (size_t ix1 = 0; ix1 < trainset.size(); ++ix1) {
    data.x[ix1].values = trainset[ix1]->getRetentionFeatures();
    data.x[ix1].dim = static_cast<int>(inhouseIndexAlphabet.size());
    data.y[ix1] = trainset[ix1]->getRetentionTime();
  }
  // build a model by training the SVM on the given training set
  char const *err_msg = svm_check_parameter(&data, &param);
  if (err_msg != NULL) {
    delete[] data.x;
    delete[] data.y;
    ostringstream temp;
    temp
          << "Error : Incorrect parameters for the SVR." << endl
          << err_msg << endl << "Execution aborted."<< endl;
    
    throw MyException(temp.str());
  }
  svm_model* m = svm_train(&data, &param);
  // save the model in the current object
  copyIndexModel(m);
  delete[] data.x;
  delete[] data.y;
  svm_destroy_model(m);
}

// perform k-validation and return as estimate of the prediction error CV = 1/k (sum(PE(k))), where PE(k)=(sum(yi - yi_pred)^2)/size
double RTModel::computeKfoldCVIndex(const vector<PSMDescription*> & psms,
                                    const double epsilon, const double c) {
  vector<PSMDescription*> train, test;
  unsigned int noPsms;
  // sum of prediction errors
  double sumPEs, PEk;
  noPsms = static_cast<unsigned int>(psms.size());
  sumPEs = 0;
  if (VERB > 2) {
    cerr << k << " fold cross validation on " << noPsms << " psms..."
        << endl;
  }
  for (unsigned int i = 0; i < k; ++i) {
    train.clear();
    test.clear();
    // get training and testing sets
    for (unsigned int j = 0; j < noPsms; ++j) {
      if ((j % k) == i) {
        test.push_back(psms[j]);
      } else {
        train.push_back(psms[j]);
      }
    }
    trainIndexRetention(train, c, epsilon);
    PEk = testIndexRetention(test);
    sumPEs += PEk;
  }
  if (VERB > 2) {
    cerr << "Done." << endl;
  }
  return (sumPEs / (double)k);
}

// test the svr on the given test set
double RTModel::testIndexRetention(vector<PSMDescription*>& testset) {
  double ms = 0.0;
  double estimatedRT;
  for (size_t ix1 = 0; ix1 < testset.size(); ix1++) {
    estimatedRT = estimateIndexRT(testset[ix1]->getRetentionFeatures());
    double diff = estimatedRT - testset[ix1]->getRetentionTime();
    ms += diff * diff;
  }
  return ms / static_cast<double>(testset.size());
}

// estimate the retention time using the svm model
double RTModel::estimateIndexRT(double* features) {
  double predicted_value;
  svm_node node;
  node.values = features;
  node.dim = static_cast<int>(inhouseIndexAlphabet.size());
  predicted_value = svm_predict(index_model, &node);
  return predicted_value;
}

// train the Support Vector Regressor for hydrophobicity
// the C is given as parameter
void RTModel::trainIndexSVRNoCCalibration(vector<PSMDescription*>& psms,
                                          const double C) {
  if (VERB >= 2) {
    cerr << "Building the hydrophobicity model with c = ..." << C << endl;
  }
  // calibrate only epsilon
  double bestError = 1e100, error;
  vector<double>::iterator it3;
  int totalIterations = static_cast<int>(grids.gridEpsilon.size());
  int step = 0;
  if (VERB > 2) {
    cerr << "Calibrating epsilon..." << endl;
    cerr << "------------------------------" << endl;
  }
  // grid search to calibrate parameters
  for (it3 = grids.gridEpsilon.begin(); it3 != grids.gridEpsilon.end(); ++it3) {
    ++step;
    if (VERB > 2) {
      cerr << "Step " << step << " / " << totalIterations << endl;
      cerr << "Evaluate = Epsilon = " << (*it3) << endl;
    }
    error = computeKfoldCVIndex(psms, (*it3), C);
    if (VERB > 2) {
      cerr << "Error = " << error << endl;
    }
    if (error < bestError) {
      eps_index = (*it3);
      bestError = error;
    }
    if (VERB > 2) {
      cerr << endl;
    }
  }
  if (VERB >= 2) {
    cerr << "Done." << endl;
  }
  if (VERB > 2) {
    cerr << "------------------------------" << endl;
    cerr << "Final Epsilon = " << eps_index << endl;
  }
  trainIndexRetention(psms, C, eps_index);
  if (VERB > 3) {
    cerr << "Done." << endl;
  }
}

// train the Support Vector Regressor for hydrophobicity
void RTModel::trainIndexSVR(vector<PSMDescription*> & psms) {
  double
      GRID_C[13] = { pow(2., -6), pow(2., -5), pow(2., -4), pow(2., -3),
                     pow(2., -2), pow(2., -1), pow(2., 0), pow(2., 1), pow(2.,
                                                                       2),
                     pow(2., 3), pow(2., 4), pow(2., 5), pow(2., 6) };
  vector<double> grid_c;
  vector<double> grid_e;
  grid_c.assign(GRID_C, GRID_C + (sizeof(GRID_C) / sizeof(GRID_C[0])));
  grid_e.assign(NORMAL_GRID_EPSILON, NORMAL_GRID_EPSILON
      + (sizeof(NORMAL_GRID_EPSILON) / sizeof(NORMAL_GRID_EPSILON[0])));
  if (VERB >= 2) {
    cerr << endl << "Training hydrophobicity index..." << endl;
  }
  // calibrate parameters using the normal grid
  double bestError = 1e100, error;
  vector<double>::iterator it2, it3;
  int totalIterations = static_cast<int>(grid_c.size() * grid_e.size());
  int step = 0;
  if (VERB > 2) {
    cerr << endl << "Calibrating SVM parameters (C, epsilon)..." << endl;
    cerr << "------------------------------" << endl;
  }
  // grid search to calibrate parameters
  for (it2 = grid_c.begin(); it2 != grid_c.end(); ++it2) {
    for (it3 = grid_e.begin(); it3 != grid_e.end(); ++it3) {
      ++step;
      if (VERB > 2) {
        cerr << "Step " << step << " / " << totalIterations << endl;
        cerr << "Evaluate = (C, epsilon) = (" << (*it2) << ", " << (*it3)
            << ")" << endl;
      }
      error = computeKfoldCVIndex(psms, (*it3), (*it2));
      if (VERB > 2) {
        cerr << "Error = " << error << endl;
      }
      if (error < bestError) {
        c_index = (*it2);
        eps_index = (*it3);
        bestError = error;
      }
      if (VERB > 2) {
        cerr << endl;
      }
    }
  }
  if (VERB > 2) {
    cerr << "------------------------------" << endl;
    cerr << "Final parameters are (c, epsilon) = (" << c_index << ", "
        << eps_index << ") with error = " << bestError << endl;
  }
  trainIndexRetention(psms, c_index, eps_index);
}

void RTModel::computeHydrophobicityIndex(vector<PSMDescription*> & psms) {
  vector<PSMDescription*>::iterator it;
  Normalizer* normalizer;
  std::size_t noFeat = inhouseIndexAlphabet.length();
  for (int i = 0; i < ('Z' - 'A' + 1); ++i) {
    our_index[i] = 0.0;
  }
  // calculate the aa features for all the psms
  for (it = psms.begin(); it != psms.end(); ++it) {
    string pep = (*it)->getPeptideSequence();
    double* features = (*it)->getRetentionFeatures();
    // amino acids
    features = fillAAFeatures(inhouseIndexAlphabet, pep, features);
  }
  // scale the rts
  PSMDescriptionDOC::setPSMSet(psms);
  PSMDescriptionDOC::normalizeRetentionTimes(psms);
  normalizer = Normalizer::getNormalizer();
  normalizer->resizeVecs(noFeat);
  // scale the values of the features between 0 and 1
  vector<double*> tmp;
  vector<double*> tRetFeat = PSMDescriptionDOC::getRetFeatures(psms);
  normalizer->setSet(tmp, tRetFeat, (size_t)0, noFeat);
  normalizer->normalizeSet(tmp, tRetFeat);
  // train retention
  trainIndexSVR(psms);
  // calculate the weights of each aa
  std::vector< std::vector<double> > a(noFeat + 1,
    std::vector<double>(noFeat));
  for (std::size_t i = 0; i < noFeat + 1; ++i)
    for (std::size_t j = 0; j < noFeat; ++j)
      if (j == (i - 1)) {
        a[i][j] = 1.0;
      } else {
        a[i][j] = 0.0;
      }
  // get weights
  double background = estimateIndexRT(&a[0][0]);
  for (std::size_t i = 1; i < noFeat + 1; ++i) {
    our_index[aaAlphabet[i - 1] - 'A'] = static_cast<float>(estimateIndexRT(&a[i][0])
        - background);
  }
  cerr << "------------------------------" << endl;
  for (unsigned int i = 0; i < psms.size(); ++i)
    for (std::size_t j = 0; j < noFeat; ++j) {
      psms[i]->getRetentionFeatures()[j] = 0.0;
    }
  PSMDescriptionDOC::unnormalizeRetentionTimes(psms);
  if (VERB > 2) {
    printInhouseIndex();
  }
}

void RTModel::printInhouseIndex() {
  cerr << endl << "Trained Hydrophobicity index: " << endl;
  for (int i = 0; i < ('Z' - 'A' + 1); ++i)
    if (aaAlphabet.find(char('A' + i)) != string::npos) {
      cerr << char('A' + i) << ":" << our_index[i] << "  ";
    }
  cerr << endl;
  cerr << "-------------------------------" << endl;
}
/*
 * END
 */

// set the type of grid
void RTModel::setGridType(const GridType& g) {
  gType = g;
  if (g == NO_GRID) {
    // just set the parameters to their default values
    gamma = INITIAL_GAMMA;
    c = INITIAL_C;
    epsilon = INITIAL_EPSILON;
    // remove any information in the grids variable
    grids.gridC.clear();
    grids.gridEpsilon.clear();
    grids.gridGamma.clear();
  } else if (g == NORMAL_GRID) {
    grids.gridGamma.assign(NORMAL_GRID_GAMMA, NORMAL_GRID_GAMMA
        + sizeof(NORMAL_GRID_GAMMA) / sizeof(NORMAL_GRID_GAMMA[0]));
    grids.gridC.assign(NORMAL_GRID_C, NORMAL_GRID_C
        + sizeof(NORMAL_GRID_C) / sizeof(NORMAL_GRID_C[0]));
    grids.gridEpsilon.assign(NORMAL_GRID_EPSILON, NORMAL_GRID_EPSILON
        + sizeof(NORMAL_GRID_EPSILON) / sizeof(NORMAL_GRID_EPSILON[0]));
  } else if (g == FINE_GRID) {
    grids.gridGamma.assign(COARSE_GRID_GAMMA, COARSE_GRID_GAMMA
        + sizeof(COARSE_GRID_GAMMA) / sizeof(COARSE_GRID_GAMMA[0]));
    grids.gridC.assign(COARSE_GRID_C, COARSE_GRID_C
        + sizeof(COARSE_GRID_C) / sizeof(COARSE_GRID_C[0]));
    grids.gridEpsilon.assign(COARSE_GRID_EPSILON, COARSE_GRID_EPSILON
        + sizeof(COARSE_GRID_EPSILON) / sizeof(COARSE_GRID_EPSILON[0]));
  } else {
    ostringstream temp;
    temp << g << "is unknown. Execution aborted." << endl;
    throw MyException(temp.str());
  }
}

string RTModel::getGridType() {
  if (gType == NO_GRID) {
    return "No calibration of parameters";
  } else if (gType == NORMAL_GRID) {
    return "Calibration via grid search";
  } else {
    return "Calibration via coarse grid followed by fine grid search";
  }
}

string RTModel::getEvaluationType() {
  if (gType != NO_GRID) {
    if (eType == SIMPLE_EVAL) {
      return "Simple evaluation (train on 3/4 of data, test on the 1/4 left)";
    } else {
      stringstream s;
      s << k << "-folds cross validation";
      return s.str();
    }
  } else {
    return "Not applicable if no calibration of parameters is carried out";
  }
}

// save the current model to a file
void RTModel::saveSVRModel(const string modelFile,
                           Normalizer* theNormalizer) {
  assert(model != NULL);
  // initializations
  //char *model_file_name = modelFile.c_str();
  double normSub = PSMDescriptionDOC::normSubRT_;
  double normDiv = PSMDescriptionDOC::normDivRT_;
  double* sub = theNormalizer->getSub();
  double* div = theNormalizer->getDiv();
  size_t* numRetFeatures = theNormalizer->getNumRetFeatures();
  // save only the SVM model
  svm_save_model(modelFile.c_str(), model);
  // save the rest of the information(normSub, normDiv, sub, div, numRetFeatures, selected features,
  // no_letters_in alphabet, letters in alphabet, our index)
  ofstream fp(modelFile.c_str(), ios::app);
  fp << "numNormalizedFeat " << (*numRetFeatures) << endl;
  fp << "SelectedFeat " << selected_features << endl;
  fp << "sub " << normSub;
  for (unsigned int i = 0; i < (*numRetFeatures); i++) {
    fp << " " << sub[i];
  }
  fp << endl;
  fp << "div " << normDiv;
  for (unsigned int i = 0; i < (*numRetFeatures); i++) {
    fp << " " << div[i];
  }
  fp << endl;
  if (selected_features & 1 << 0) {
    fp << "alphabet " << inhouseIndexAlphabet.length();
    for (unsigned int i = 0; i < inhouseIndexAlphabet.length(); ++i) {
      fp << " " << inhouseIndexAlphabet[i] << " "
          << our_index[inhouseIndexAlphabet[i] - 'A'];
    }
    fp << endl;
  }
  fp.close();
}

// load a model from a file
void RTModel::loadSVRModel(const string modelFile,
                           Normalizer* theNormalizer) {
  // destroy any previous model
  if (model != NULL) {
    svm_destroy_model(model);
  }
  theNormalizer->setNumFeatures(0);
  // load only the SVM model
  model = svm_load_model(modelFile.c_str());
  // load the rest of the information(normSub, normDiv, sub, div, numRetFeatures, selected features,
  // no_letters_in alphabet, letters in alphabet, our index)
  string line, label;
  ifstream fp(modelFile.c_str());
  fp >> line;
  while (line.find("numNormalizedFeat") == string::npos) {
    fp >> line;
  }
  // number of retention features
  size_t numRtFeat;
  fp >> numRtFeat;
  theNormalizer->setNumberRetentionFeatures(numRtFeat);
  // selected features
  fp >> label >> selected_features;
  // sub
  double* sub = theNormalizer->getSub();
  fp >> label >> PSMDescriptionDOC::normSubRT_;
  for (unsigned int i = 0; i < numRtFeat; ++i) {
    fp >> sub[i];
  }
  // div
  double* div = theNormalizer->getDiv();
  fp >> label >> PSMDescriptionDOC::normDivRT_;
  for (unsigned int i = 0; i < numRtFeat; ++i) {
    fp >> div[i];
  }
  // our index
  if (selected_features & 1 << 0) {
    int no_aa;
    char aa;
    double v;
    for (int i = 0; i < 'Z' - 'A' + 1; ++i) {
      our_index[i] = 0.0;
    }
    inhouseIndexAlphabet = "";
    fp >> label >> no_aa;
    for (int i = 0; i < no_aa; ++i) {
      fp >> aa >> v;
      inhouseIndexAlphabet += aa;
      our_index[aa - 'A'] = static_cast<float>(v);
    }
  }
  noFeaturesToCalc = *(theNormalizer->getNumRetFeatures());
}

// calculate the difference in hydrophobicity between 2 peptides
double RTModel::calcDiffHydrophobicities(const string& parent,
                                         const string& child) {
  double sumParent, sumChild;
  sumParent = indexSum(krokhin_index, parent);
  sumChild = indexSum(krokhin_index, child);
  return abs(sumParent - sumChild);
}

// print the table of features
void RTModel::printFeaturesInUse(ostringstream& oss) {
  int i;
  oss << " *" << noFeaturesToCalc
      << " features should be used to generate the model." << endl;
  oss << " *Feature groups used: ";
  for (i = 0; i < NO_FEATURE_GROUPS - 1; i++)
    if (selected_features & 1 << i) {
      oss << feature_groups[i] << ", ";
    }
  if (selected_features & 1 << i) {
    oss << feature_groups[i];
  }
  oss << endl;
}

// print the inhouse index to filename
void RTModel::printInhouseIndex(string& filename) {
  ofstream out;
  if (VERB > 2) {
    cerr << "Write hydrophobicity index to " << filename << endl;
  }
  out.open(filename.c_str());
  for (int i = 0; i < ('Z' - 'A' + 1); ++i)
    if (aaAlphabet.find(char('A' + i)) != string::npos) {
      out << char('A' + i) << "\t" << our_index[i] << endl;
    }
  if (VERB > 2) {
    cerr << "Done " << endl;
  }
  out.close();
}

// print psms to file
void RTModel::printPsms(string& filename, vector<PSMDescription*> & psms) {
  ofstream out;
  out.open(filename.c_str());
  for (unsigned int i = 0; i < psms.size(); ++i) {
    out << *psms[i] << endl;
  }
  out.close();
}
